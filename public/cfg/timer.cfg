#!/bin/bash
#cant call back to tasks - its a help file!
################################### links
#shift $PWD/public/cfg/lib.trap.sh

trap error_handler ERR                                                           # ! ! ! TRAP ERR ! ! !

gxmessage(){
    exec $CFG_DIR/gxmessage.sh "$@"
}
check_corrupted(){
    echo2 "check_corrupted()"
    local    file="$1"

   
minimumsize=10
actualsize=$(du -b "$file" | cut -f 1)
if [[ $actualsize -lt $minimumsize ]]; then
 red "file is corrupted - 0kb -> deleting!"
        rm  "$file"
else
   green "$file:  is ok"
        ls -l "$file"
         
fi

}

error_handler(){
    local msg='found error'
    cyan "$msg"
    #echo4 "$msg" 
    #choose4 $STATIC_DIR/exit.txt
    Backtrace1

    #dbus-send --system --print-reply     --dest="org.freedesktop.UPower"     /org/freedesktop/UPower     org.freedesktop.UPower.Suspend
    #suspension
    #profit 
    if [ "$STRICT" = true ];then

        seconds=360
        echo -n  "going to sleep in: " 
        red "$seconds seconds"
        sleep1 $seconds 
        suspension
    fi

    exiting

}

suspension(){
    dbus-send --system --print-reply     --dest="org.freedesktop.UPower"     /org/freedesktop/UPower     org.freedesktop.UPower.Suspend
}

printing1(){
    local input_ws="$1" 
    local file_txt="$2"
    local lang="$3"

    local line1=`cat $file_txt | head -1`
    local line2=`cat $file_txt | head -2 | tail -1`
    #local line3=$(echo "$line2"|sed 's/ /:1,/g');

    if [ $GUI = true ]
    then
        if [[ $lang = ru  ||  $lang = hi ]];
        then
            notify-send $TIMEOUT_NS "$line1" "$line2"   
        else
            notify-send $TIMEOUT_NS "$line1"
        fi
    fi

    cat -n $file_txt 

    #update_file $log_txt "$line1 | $line2"    
}



play1(){


    echo2 "play1() got: $1 | $2"

    local file="$1"

    if [ $PLAYING_ON = false ];then
        export PLAYING_ON=true
        local lang="$2"
        local lang_repeat=\$"$lang"R   # Name of variable (not value!).
        local times=`eval "expr \"$lang_repeat\" "`
        if [ "$timer" != '' ];then

            #declare  -i  counter
            local counter=0
            while [  $counter -lt  $times ]; do
                if [ "$SILENCE" = false ];then
                    play -V1 -q  "$1"
                fi
                (( counter++ ))
            done
        else
            play -V1 -q  "$1"
        fi
        export PLAYING_ON=false
    else
        red 'playing is already on'
        Backtrace1
    fi

}

translate_f(){
   echo2 "translate_f() got:"
    echo2 "input: $1 | lang: $2"
    
    local silent_fetch=$SILENT_FETCH
    local silent=$SILENT
    local lang="$2"
 

    local input="$1" #translate src
    local input_wsp=$(echo "$input"|sed 's/ /+/g');
    local input_ws=$(echo "$input"|sed 's/ /_/g');

    local file_txt=$(  echo $dir_txt/${input_ws}_${lang}.txt )
    local file_mp3=$(  echo $dir_mp3/${input_ws}_${lang}.mp3 )



    check_corrupted "$file_txt"
    local files1=$(ls  $file_txt 2> /dev/null )

    if [ ! "$files1"  ] #|| [ ! "$files2" ]
    then
        echo2 "fetch txt"
        result=$(wget -U "Mozilla/5.0" -qO - "http://translate.google.com/translate_a/t?client=t&text=$input_wsp&sl=en&tl=$lang" ) 
        cleaner=$(echo "$result" | sed 's/\[\[\[\"//') 
        echo2 "$cleaner"
        phonetics=$(echo "$cleaner" | cut -d \" -f 5)
        output=$(echo "$cleaner" | cut -d \" -f 1)
        output_wsp=$(echo "$output"|sed 's/ /+/g');
        output_ws=$(echo "$output"|sed 's/ /_/g');

        #touch "$file_txt"
        echo "$output" >   "$file_txt"

        if [  "$lang" = 'ru' ] || [ "$lang" = 'hi' ]
        then 
            echo  "$phonetics" >>   "$file_txt"
        fi
    else
        cat $file_txt
        echo2 "cache copy"
    fi
    if [ "$silent_fetch" = false ];then
        output=`cat $file_txt | head -1`
        #blue "fetch for: $output"
        output_wsp=$(echo "$output"|sed 's/ /+/g');
        output_ws=$(echo "$output"|sed 's/ /_/g');


        check_corrupted "$file_mp3"
        local files2=$(ls  $file_mp3 2> /dev/null )
        if [ ! "$files2" ];then
            echo2 'fetch sound'
            if [ "$lang" = 'tl' ]
            then
                echo1 $output
                echo -n "$output" | text2wave -o "$file_mp3" #/tmp/1.wav | lame /tmp/1.wav  $file_mp3 
            else
                ( wget -U Mozilla -q -O - "$@" translate.google.com/translate_tts?ie=UTF-8\&tl=${lang}\&q=${output_wsp} > $file_mp3 \&\& play1  $file_mp3 \&)
            fi
        else
            echo2 'no fetch sound'
        fi
    fi

    str=`cat "$file_txt" `
    str1=`echo  $str`

    printing1 "$input_ws" "$file_txt" "$lang"
    if [ "$silent" = false ];then
        echo1 'play1 !'
        echo1 "play1 $file_mp3" 
        if [ "$silent_fetch" = true ]
        then
            #  ( play1  $file_mp3 &)
            echo2 'silent fetch'
        else
            play1  "$file_mp3" "$lang"
        fi

    fi
    #eval "$1=\"$str1\""  # Assign new value.
}





export EMPATHIC='false'
export INSTALL='false'
export PROFIT='true'

export VERBOSE='true'
export STRICT='false'
###
export TIMEOUT_NS='-t 10000'

#########url links
export url_blog="http://thoughts-about-something.blogspot.co.il"
export url_calendar="https://www.google.com/calendar/render?tab=mc"
export url_tasks="https://mail.google.com/tasks/ig?pli=1"
export mm_link='http://drichard.org/mindmaps/'



#absolute path
export ABSOLUTE_DIR=~/.magnify_the_small

#private reports | blogging
export private_txt=/tmp/private.txt 
export dir_txt=$PRIVATE_DIR/tmp/txt
#~/tmp/bash_koans/txt
export dir_mp3=/tmp
export blank_txt=/tmp/blank.txt

export readme_md=$ABSOLUTE_DIR/README.md
export missions_txt=/tmp/missions.txt
export schedule_txt=/tmp/gcalcli_agenda_full.txt

export mind_map_png=/tmp/mm.png
#relative dirs
export PUBLIC_DIR=$ABSOLUTE_DIR/public
export PRIVATE_DIR=$ABSOLUTE_DIR/private
##
export CFG_DIR=$PUBLIC_DIR/cfg
#tmp
export TMP_DIR=$PUBLIC_DIR/tmp
export REPORT_DIR=$TMP_DIR/reports
export MORNING_DIR=$TMP_DIR/morning
export TESTS_DIR=$TMP_DIR/tests



export STATIC_DIR=$PUBLIC_DIR/story/static
export DYNAMIC_DIR=$PUBLIC_DIR/story/dynamic

export TASKS_DIR=$PUBLIC_DIR/tasks 
export MENUS_DIR=$PUBLIC_DIR/menus
export KOANS_DIR=$PUBLIC_DIR/koans
export SCREENS_DIR=$PUBLIC_DIR/screens

####### .sh
export tasks_sh="$PUBLIC_DIR/tasks.sh"
#export tpng="$TASKS_DIR/txt_to_png.sh"
################################  language stuff####################
arr1=( IT AR HI RU )
#arr2=( )
export itR=1
export tlR=1
export enR=1
export ruR=1
export arR=2
export hiR=3
#dir_essay=~/tmp/timer2/essays
##################################  global vars##################


#export series1="glossary,input_task,motivation_start,mindmap, edit,input_task,sleep,time,sleep,suspend,rules"
export NAME1='Ofer'

date1="$(date +%H:%M)"
export PLAYING_ON=false
export LANG_ESSAY=ru

export color_arr1=( blue green red black )
export GUI='true'
export SILENT_FETCH=false
export SILENT=false
export TIMEOUT1=20
export LESSON=14
export TRANSLATE=true
export SLEEP=30
#export GXMESSAGE1=echo  -ontop -sticky -timeout 10 -buttons \'last task is: "$last_task"\' "message1"

GXMESSAGET="-wrap -ontop -sticky -timeout 20"
#GXMESSAGE1="-nofocus -wrap -ontop -sticky -timeout 20"
#GXMESSAGE0="-nofocus -wrap -ontop -sticky"
#export ICONIC='' 
export ICONIC='-iconic'
export SLEEPS=15
export SUSPEND=true
export SILENCE=false
export INPUT_THANKS=true
################################################   messages
last_task="do for other first"
msg_remind_me="write an automation for this task"
msg_others="do for other first and have a blessing on your head"
msg_suspend='do sport for 5 seconds'
msg_m0='I am writing short essay in many languages'
msg_m1='sign one circle on the wall' 
msg_m3='please update list' 
msg_m2='excellent' 
msg_m4='good'
msg_m6='write the impossible - the hardest thing for you' 
msg_m7='update your notebook please positively' 
msg_m8='you know what is right and what to do now' 
#how easier can it realy be ?"
last_thanks="you can do it - it is so easy"
last_essay="essay step"
#timer2 - one step for man - one step for"
last_suspend="well - I am tired - i am going to sleep now - thanks for the fish" 
last_bash="linux programming start here"
#well - I am tired - i am going to leep2 now - thanks for the fish" 
last_camera_before="" #say cheese little mouse" 
last_camera_after="take a picture of your notebook please" 
#this is much better" 
export itR=1
export tlR=1
export enR=1
export ruR=1
export arR=2
export hiR=3
############################ colors
RESTORE='\033[0m'

RED='\033[00;31m'
GREEN='\033[00;32m'
YELLOW='\033[00;33m'
BLUE='\033[00;34m'
PURPLE='\033[00;35m'
CYAN='\033[00;36m'
LIGHTGRAY='\033[00;37m'

LRED='\033[01;31m'
LGREEN='\033[01;32m'
LYELLOW='\033[01;33m'
LBLUE='\033[01;34m'
LPURPLE='\033[01;35m'
LCYAN='\033[01;36m'
WHITE='\033[01;37m'


#dir




#story
#export philo_txt=$STATIC_DIR/philo.txt
#export police_txt=$STATIC_DIR/police.txt
#export quotes_txt=$STATIC_DIR/quotes.txt
#export earth_txt=$STATIC_DIR/earth.txt
#export magician=$STATIC_DIR/magician.txt

#############  .bashrc related
alias duh="du -h -d 0 [^.]*"

spell1(){
    aspell -a <<< "$1"
}

######################################## functions !!!!!!!!!!!!!!!
cyan() {
    echo -e "${LCYAN}$1"
    tput sgr0
    #fi
}
white() {
    echo -e "${WHITE}$1"
    tput sgr0
}
green() {
    echo -e "${LGREEN}$1"
    tput sgr0
}

red() {
    echo -e "${LRED}$1"
    tput sgr0
}
yellow() {
    echo -e "${LYELLOW}$1"
    tput sgr0
}
blue() {
    echo -e "${LBLUE}$1"
    tput sgr0
}
echo2(){
    if [ "$VERBOSE" = true ];then

        echo "$1"
        cyan "log: $1"
    fi

}
echo22(){
    echo -n '_'
}
random1()
{
    local num="$1"
    if [ $num -eq 0 ];then
        error_handler
    fi

    let "r = $RANDOM % $num"
    #green "r = $r"
    #counter=$r
    #let "reminder = $counter % 4"
    #echo1 "the reminder is: $reminder"
    return $r
}
rainbow(){
    local line1="$1"
    random1 4
    local num=$?
    #red "num: $num"
    local color0="${color_arr1[$num]}"

    #gxmessage "$line1" -buttons "$line3" -sticky -timeout 11 -title "$input_ws"  -geometry 600*900 -font "serif bold 18" -wrap -fg $color $ICONIC 
    gxmessage "$line1" -title "reminder:"  -geometry 600*900 -font "serif bold 18" -wrap -fg $color0 

}
split2(){
    echo2 "split2(): $1"
    while read $1 
    do
        eval items=($line)
        for i in "${items[@]}"
        do
            echo $i
        done
    done
}
echo4(){
    echo2 "echo4() got: $1"
    #sleep1 3
    if [ "$1" = '' ];then

        error_handler 
        return
    fi
    #split2 "$1"

    local lang1=$LANG
    echo2 "lang1: $lang1"
    if [ "$lang1" = '' ];then
        random1 4
        local num=$?
        #red "num: $num"
        lang0="${arr1[$num]}"
        lang1=$(lower $lang0)
    fi



    #red "lang: $lang1"
    #echo "playing is on? $PLAYING_ON"
    local str="$1"
    yellow "$str"

    translate_f  "$str" "en"
    translate_f  "$str" "$lang1"

}
echo5(){

    sleep1 3
    if [ "$1" = '' ];then
        #exiting
        error_handler
        return
    fi
    #count words in sentence - if lower then 4 - translate_f also to: ar, hi
    num=`echo "$1" | wc -w`
    str="$1"
    if [ "str" = '' ];then
        exiting
    else



        translate_f  "$str" en 
        #echo "$str" | flite
        sleep1 2
        translate_f  "$str" it 
        sleep1 2
        translate_f  "$str" ru 
        if [ $num -lt 4 ];then
            sleep1 2
            translate_f  "$str" hi 
            sleep1 2
            translate_f  "$str" ar 
            sleep1 2
            translate_f  "$str" tl 
        fi

    fi
}


echo3(){
    #caller 0
    #red "$1"

    echo -n "_"
}

echo1(){


    echo -n "."
    #red "$2"

    #green ""
    #$1"

    #caller 0


}

messageANS() {

    local title="$1"
    local file="$2"
    #local result=
    result=$( gxmessage -center  -nofocus       -title "$title" -file $file -timeout 15 -entry )

    if [ "$result" != '' ];then
        cat $rules_txt > /tmp/rules
        echo "$result" > $rules_txt
        cat /tmp/rules >> $rules_txt
    fi


}
messageFYN() {

    local title="$1"
    local file="$2"
    #local result=

    result=$( gxmessage  -buttons "No":1,"Yes":2       -title "$title" -file $file $GXMESSAGET )
    echo "$?"
    return "$?"
}
messageYN() {

    local title="$1"
    local str="$2"
    #local result=''

    if [ "$GUI" = 'true' ];then
        result=$( gxmessage -buttons "No":1,"Yes":2          -title "$title" "$str"  $GXMESSAGET )
    else
        green "$str"
        read result
        if [ $result = 'y' ];then
            result=2
            let "result = 2"
        else
            let "result = 1"
        fi
        #echo $result
    fi
    echo "$?"
    #return "$?"
    return $result
}
Backtrace2 () {

    echo "Backtrace is:"
    i=0
    while caller $i
    do
        i=$((i+1))
    done

}
function Backtrace1 
{
    local _start_from_=0

    local params=( "$@" )
    if (( "${#params[@]}" >= "1" ))
    then
        _start_from_="$1"
    fi

    local i=0
    local first=false
    while caller $i > /dev/null
    do
        if test -n "$_start_from_" && (( "$i" + 1   >= "$_start_from_" ))
        then
            if test "$first" == false
            then
                red "BACKTRACE IS:"
                first=true
            fi
            caller $i
        fi
        let "i=i+1"
    done
    echo '_+_+_+_+_+'
}
exiting()
{
    local file=$STATIC_DIR/exit.txt
    if [ "$VERBOSE" = true ];then
        Backtrace1
    fi


    red 'exiting!!'
    #echo 'exiting' | flite
    #choose4 $file
        sleep1 2
        

        echo ''





    remind_me_please 

    exit
}
remind_me_please(){
    #    red 'COMMANDS:'
    #    cat $DYNAMIC_DIR/learn/commands.txt
    #
    #    local command1=`cat $DYNAMIC_DIR/learn/commands.txt | head -1`
    #
    #    echo 'search google for the top command?'
    #    read answer
    #    if [ "$answer" = y ];then
    #        xdg-open http://google.com/${command1}
    #    fi
    #    white 'to be implemented: use url.txt'
    
    file=$DYNAMIC_DIR/day/plan.txt 
    str6=$( date | awk -F ' ' '{print $4}' )
    echo "$str6" >> $file 
    ( gedit $file &)
}

sleep1()
{
    local sec="$1"
    blue   '..'
    #sleep $sec"
    #choose4 $STATIC_DIR/sleep.txt
    sleep ${sec}s
}

log1()
{
    str8=`echo "\t\t\t\tWORKFLOW";echo $workflow`
    str7=`echo "\t\t\t\tSPORT";cat  "$sport_txt" | head -2`
    str3=`cat  "$todo_txt" | head -2`
    str6=$( date | awk -F ' ' '{print $4}' )
    str5=`cat  "$timing_txt"  | head -3`
    str4=`cat  "$done_txt" | head -2` #points
    str1=""
    str2=$( white "\t\t\t\t\t\t\t$str6";  yellow "$str4"; green "$str3"; red "$str5";red "$str7";cyan "$str8" )
    echo "$str2"
}
log2(){

    str9=`cat  "$glossary_txt"  | head -3`
    str8=`cat  "$product_txt"  | head -3`
    str7=`cat  "$motivations_txt" | head -3 `

    str2=$( cyan "$str7"; white "$str8" ;green "$str9" )

    echo "$str2"
}



log3(){
    str=`cat  "$commitment_txt"`
    str2=$( white "$str"; )
    echo "$str2"

}




##########################################tts engine
#http://www.thegeekstuff.com/2010/03/espeak-speech-synthesizer-for-ubuntu/

##########################################vim:
#:set filetype=sh #for identation, patern matching
#:set syntax=sh
#,ic - comment multiple lines

####################################local tts engines:
#echo 'Вы можете играть с ним ?' | espeak -v ru -s 14
#echo "russian words" | festival --tts --language russian

############## commands to remember:
#1.mpack,2.sendmail /etc/ssmtp/ssmtp.conf -> update password


update_lang(){
    export LANG=$1
    red "update translated language to: $LANG"
}
export LANG=''
god(){
    white "$1"
}
robot(){
    cyan "robot:"
    white "$1"
}
me(){
    green "$1"
}
profit(){
    if [  "$PROFIT" = true ];then
        choose5 $STORY_DIR/wish.txt
    fi
}

update_file(){
    echo "update_file got: file: $1 | msg: $2 | $3"
    local file="$1"
    local msg="$2"
    #`echo $2`
    if [ "$msg" != '' ];then
        if [  "$PROFIT" = true ];then
            echo5 "$msg"
        fi
        cat $file > /tmp/1.txt 
        echo "$msg" > $file
        cat /tmp/1.txt >> $file
    fi
}

pids1(){
    echo "pids() got: $1"
    PIDS=$(pidof sh $1)  # Process IDs of the various instances of this script.
    #kill $PIDS
    P_array=( $PIDS )    # Put them in an array (why?).
    echo "$PIDS"           # Show process IDs of parent and child processes.
    let "instances = ${#P_array[*]} - 1"  # Count elements, less 1.
    # Why subtract 1?
    echo "$instances instance(s) of this script running."


    if [ $instances -gt 2 ];then
        #exiting
        red 'u may like to kill some..'
        echo 'too many instances are running' | flite
        #exiting
        #suspension

        exit 1
    fi

}

random_quote1(){
    file="$1"
    max=`cat -b $file | wc -l`
    random1 $max
    num=$?
    str=`cat $file | head -$num | tail -1`
    echo5 "$str" 

}

lower() { echo ${@,,}; }

higher() { echo ${@^^}; }


choose4(){
    echo2 "choose4() got: $1"
    local file=$1
local str=`cat $file | sort --random-sort | head -n 1`

    echo -n "choosen line: "
    yellow "$str"
    echo4 "$str" 



}

choose5(){
    echo2 "choose5() got: $1"
    local file=$1
local str=`cat $file | sort --random-sort | head -n 1`

    echo -n "choosen line: "
    yellow "$str"
    echo5 "$str" 
}

add_line(){
    echo2 "input line got: file:$1 title:$2 3:$3"
    #latest modifications: 
    #pass reference by supplying name of global variable.
    local file=$1
    local title="$2"
    local when="$3"
    answer=$( gxmessage  -title "$title" -file  "$file" -ontop -timeout 10 -entry )
    if [ "$answer" = exit ]
    then
        exiting
    fi
    if [ $TRANSLATE = true ]
    then
        str=`cat $file | head -1`
        #echo4 "$answer" 
    fi

    if [ "$when" = 'true' ];then
        date1="$(date +%H:%M)"
        str="$date1 - $answer"
    else
        str="$answer"
    fi

    update_file $file "$str"
}

split1(){
    echo '' > /tmp/glossary.txt
    echo2 'split()'
    local file=$1
    #cat $file
    old_IFS=$IFS
    IFS=$' · '
    lines=($(cat $file)) # array
    IFS=$old_IFS
    #register signals
    for line in "${lines[@]}"
    do
        if [ "$line" != '' ]
        then
            echo  "$line" >> /tmp/glossary.txt
        fi
    done
    cat  /tmp/glossary.txt 
    ls -l $file
}

eacher(){
    echo2  "eacher() got: 1: $1     2: $2"
    local question="$2"
    local command="$1"
    if [ "$EMPATHIC" = true ];then
        answer=$( messageYN "y/n question" "$question" )
        if [ "$answer" = 2 ];then
            echo 'exec command'
            eval "$command" 
        fi
    else
        echo 'exec command'
        eval "$command" 

    fi





}

trap "eval exiting" SIGINT SIGTERM



export -f eacher 
export -f split1
export -f random_quote1
export -f update_lang 
export -f update_file
export -f god 
export -f robot 
export -f me 

export -f echo1 
export -f echo3 
export -f echo2 

export -f exiting
export -f log1 
export -f sleep1
export -f messageYN 


export -f green
export -f red 
export -f blue
export -f yellow
export -f Backtrace1

#latest

export -f spell1 
export -f choose4 
export -f choose5 
export -f add_line 
export -f pids1 

#installation
export motivations_txt="$STATIC_DIR/motivations.txt"
#
export done_txt=$REPORT_DIR/done.txt
export ideas_txt=$REPORT_DIR/ideas.txt
export now_txt=$REPORT_DIR/now.txt
export scrap_txt=$REPORT_DIR/scrap.txt

if [ "$INSTALL" = true ];then
    touch $ideas_txt
    touch $done_txt
    touch $now_txt
    touch $scrap_txt
    #mkdir -p ~/tmp/bash_koans/txt

    #mkdir -p /home/dao01/.magnify_the_small/private/tmp/txt/
fi


export log_txt=/tmp/log.txt
touch $log_txt
