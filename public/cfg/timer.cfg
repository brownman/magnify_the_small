#!/bin/bash
#cant call back to tasks - its a help file!
################################### links
#shift $PWD/public/cfg/lib.trap.sh
#!/bin/bash




#echo "doing something wrong now .."
#echo "$foo"
#exit
#set -o pipefail  # trace ERR through pipes
#set -o errtrace  # trace ERR through 'time command' and other functions
error_handler(){
    local msg='found error'
    cyan "$msg"
    #echo4 "$msg" 
    #choose4 $STATIC_DIR/exit.txt
    Backtrace1

    #dbus-send --system --print-reply     --dest="org.freedesktop.UPower"     /org/freedesktop/UPower     org.freedesktop.UPower.Suspend
    #suspension
    #profit 
    if [ "$STRICT" = true ];then

        seconds=360
        echo -n  "going to sleep in: " 
        red "$seconds seconds"
        sleep1 $seconds 
        #suspesion
    fi

    exiting
}

function error() {
JOB="$0"              # job name
LASTLINE="$1"         # line of error occurrence
LASTERR="$2"          # error code
echo "ERROR in ${JOB} : line ${LASTLINE} with exit code ${LASTERR}"
Backtrace1
exit 1
}

#trap 'error ${LINENO} ${$?}' ERR
trap error_handler ERR                                                           # ! ! ! TRAP ERR ! ! !
#source $PWD/public/cfg/tmp/lib.trap.sh

gxmessage(){
    #proxy calls to this func|for better gui/cli switch
    exec $CFG_DIR/gxmessage.sh "$@"
}


suspension(){
    dbus-send --system --print-reply     --dest="org.freedesktop.UPower"     /org/freedesktop/UPower     org.freedesktop.UPower.Suspend
}

is_valid(){
    echo -n  "is_valid() got:"
    cyan "$1"

    if [ "$1" = '' ];then
        red 'no arg given'
        error_handler
    fi

    local file=$1
    local result


    yellow 'check existance'
    #local files=$(ls  $file 2> /dev/null )
    #[ ! "$files"  ]]
    if [ -e $file ];then
        green 'file exist'
        if  [ -s $file ];then
            green 'file has content'
            let "result = 1"
        else
            red 'file is empty'
        fi
    else
        red 'file not exist'
    fi
    #yellow $result 
    echo $result
}

#exit
#        red 'file not exist'
#        result=1
#        
#
#        green 'file exist'
#
#        ls -l $file
#        exiting
#
#    actualsize=$(du -b "$file" | cut -f 1)
#
#        #yellow 'check corruption'
#        #check_corrupted "$file" #remove if size is 0kb
#        if [ $actualsize -eq 0 ];then
#            red 'file is corrupted'
#            result=1 
#        fi
#    fi
#    yellow "result: $result"
#    return $result


    export EMPATHIC='true'
    export INSTALL='true'
    export PROFIT='true'

    export VERBOSE='true'
    export STRICT='false'
    ###
    export TIMEOUT_NS='-t 10000'

    #########url links
    export url_blog="http://thoughts-about-something.blogspot.co.il"
    export url_calendar="https://www.google.com/calendar/render?tab=mc"
    export url_tasks="https://mail.google.com/tasks/ig?pli=1"
    export mm_link='http://drichard.org/mindmaps/'



    #absolute path
    export ABSOLUTE_DIR=~/.magnify_the_small

    #private reports | blogging
    export private_txt=/tmp/private.txt 

    #~/tmp/bash_koans/txt
    export dir_mp3=/tmp
    export blank_txt=/tmp/blank.txt

    export readme_md=$ABSOLUTE_DIR/README.md
    export missions_txt=/tmp/missions.txt
    export schedule_txt=/tmp/gcalcli_agenda_full.txt

    export mind_map_png=/tmp/mm.png
    #relative dirs
    export PUBLIC_DIR=$ABSOLUTE_DIR/public
    export PRIVATE_DIR=$ABSOLUTE_DIR/private
    ##
    export CFG_DIR=$PUBLIC_DIR/cfg

    export PLUGINS_DIR=$PUBLIC_DIR/plugins

    export STORY_DIR=$PUBLIC_DIR/story
    #tmp
    export TMP_DIR=$PUBLIC_DIR/tmp
    export REPORT_DIR=$TMP_DIR/reports
    export MORNING_DIR=$TMP_DIR/morning
    export TESTS_DIR=$TMP_DIR/tests





    export STATIC_DIR=$PUBLIC_DIR/story/static
    export DYNAMIC_DIR=$PUBLIC_DIR/story/dynamic

    export TASKS_DIR=$PUBLIC_DIR/tasks 
    export MENUS_DIR=$PUBLIC_DIR/menus
    export KOANS_DIR=$PUBLIC_DIR/koans
    export SCREENS_DIR=$PUBLIC_DIR/screens

    ####### .sh
    export tasks_sh="$PUBLIC_DIR/tasks.sh"
    #export tpng="$TASKS_DIR/txt_to_png.sh"
    ################################  language stuff####################
    arr1=( IT AR HI RU )
    #arr2=( )
    export itR=1
    export tlR=1
    export enR=1
    export ruR=1
    export arR=2
    export hiR=3
    #dir_essay=~/tmp/timer2/essays
    ##################################  global vars##################


    #export series1="glossary,input_task,motivation_start,mindmap, edit,input_task,sleep,time,sleep,suspend,rules"
    export NAME1='Ofer'

    date1="$(date +%H:%M)"
    export PLAYING_ON=false
    export LANG_ESSAY=ru

    export color_arr1=( blue green red black )
    export GUI='false'
    export SILENT_FETCH=false
    export SILENT=false
    export TIMEOUT1=20
    export LESSON=14
    export TRANSLATE=true
    export SLEEP=30
    #export GXMESSAGE1=echo  -ontop -sticky -timeout 10 -buttons \'last task is: "$last_task"\' "message1"

    GXMESSAGET="-wrap -ontop -sticky -timeout 20"
    #GXMESSAGE1="-nofocus -wrap -ontop -sticky -timeout 20"
    #GXMESSAGE0="-nofocus -wrap -ontop -sticky"
    #export ICONIC='' 
    export ICONIC='-iconic'
    export SLEEPS=15
    export SUSPEND=true
    export SILENCE=false
    export INPUT_THANKS=true
    ################################################   messages
    last_task="do for other first"
    msg_remind_me="write an automation for this task"
    msg_others="do for other first and have a blessing on your head"
    msg_suspend='do sport for 5 seconds'
    msg_m0='I am writing short essay in many languages'
    msg_m1='sign one circle on the wall' 
    msg_m3='please update list' 
    msg_m2='excellent' 
    msg_m4='good'
    msg_m6='write the impossible - the hardest thing for you' 
    msg_m7='update your notebook please positively' 
    msg_m8='you know what is right and what to do now' 
    #how easier can it realy be ?"
    last_thanks="you can do it - it is so easy"
    last_essay="essay step"
    #timer2 - one step for man - one step for"
    last_suspend="well - I am tired - i am going to sleep now - thanks for the fish" 
    last_bash="linux programming start here"
    #well - I am tired - i am going to leep2 now - thanks for the fish" 
    last_camera_before="" #say cheese little mouse" 
    last_camera_after="take a picture of your notebook please" 
    #this is much better" 
    export itR=1
    export tlR=1
    export enR=1
    export ruR=1
    export arR=2
    export hiR=3
    ############################ colors
    RESTORE='\033[0m'

    RED='\033[00;31m'
    GREEN='\033[00;32m'
    YELLOW='\033[00;33m'
    BLUE='\033[00;34m'
    PURPLE='\033[00;35m'
    CYAN='\033[00;36m'
    LIGHTGRAY='\033[00;37m'

    LRED='\033[01;31m'
    LGREEN='\033[01;32m'
    LYELLOW='\033[01;33m'
    LBLUE='\033[01;34m'
    LPURPLE='\033[01;35m'
    LCYAN='\033[01;36m'
    WHITE='\033[01;37m'


    #dir




    #story
    #export philo_txt=$STATIC_DIR/philo.txt
    #export police_txt=$STATIC_DIR/police.txt
    #export quotes_txt=$STATIC_DIR/quotes.txt
    #export earth_txt=$STATIC_DIR/earth.txt
    #export magician=$STATIC_DIR/magician.txt

    #############  .bashrc related
    alias duh="du -h -d 0 [^.]*"

    spell1(){
        aspell -a <<< "$1"
    }

    ######################################## functions !!!!!!!!!!!!!!!
    cyan() {
        echo -e "${LCYAN}$1"
        tput sgr0
        #fi
    }
    white() {
        echo -e "${WHITE}$1"
        tput sgr0
    }
    green() {
        echo -e "${LGREEN}$1"
        tput sgr0
    }

    red() {
        echo -e "${LRED}$1"
        tput sgr0
    }
    yellow() {
        echo -e "${LYELLOW}$1"
        tput sgr0
    }
    blue() {
        echo -e "${LBLUE}$1"
        tput sgr0
    }
    echo2(){
        if [ "$VERBOSE" = true ];then

            echo "verbose: $1"
        fi

    }
    echo22(){
        echo -n '_'
    }
    random1()
    {
        local num="$1"
        if [ $num -eq 0 ];then
            error_handler
        fi

        let "r = $RANDOM % $num"
        #green "r = $r"
        #counter=$r
        #let "reminder = $counter % 4"
        #echo1 "the reminder is: $reminder"
        return $r
    }
    rainbow(){
        local line1="$1"
        random1 4
        local num=$?
        #red "num: $num"
        local color0="${color_arr1[$num]}"

        #gxmessage "$line1" -buttons "$line3" -sticky -timeout 11 -title "$input_ws"  -geometry 600*900 -font "serif bold 18" -wrap -fg $color $ICONIC 
        gxmessage "$line1" -title "reminder:"  -geometry 600*900 -font "serif bold 18" -wrap -fg $color0 

    }
    split2(){
        echo2 "split2(): $1"
        while read $1 
        do
            eval items=($line)
            for i in "${items[@]}"
            do
                echo $i
            done
        done
    }
  

    echo3(){
        #caller 0
        #red "$1"

        echo -n "_"
    }

    echo1(){


        echo -n "."
        #red "$2"

        #green ""
        #$1"

        #caller 0


    }

    messageANS() {

        local title="$1"
        local file="$2"
        #local result=
        result=$( gxmessage -center  -nofocus       -title "$title" -file $file -timeout 15 -entry )

        if [ "$result" != '' ];then
            cat $rules_txt > /tmp/rules
            echo "$result" > $rules_txt
            cat /tmp/rules >> $rules_txt
        fi


    }
    messageFYN() {

        local title="$1"
        local file="$2"
        #local result=

        result=$( gxmessage  -buttons "No":1,"Yes":2       -title "$title" -file $file $GXMESSAGET )
        echo "$?"
        return "$?"
    }
    messageYN() {

        local title="$1"
        local str="$2"
        local result=0

        if [ "$GUI" = 'true' ];then
            result=$( gxmessage -buttons "No":1,"Yes":2          -title "$title" "$str"  $GXMESSAGET )
        else
            green "$str"
            read result
            if [ "$result" = 'y' ];then
                result=2
                let "result = 2"
            else
                let "result = 1"
            fi
        fi
        return $result
    }
    Backtrace2 () {

        echo "Backtrace is:"
        i=0
        while caller $i
        do
            i=$((i+1))
        done

    }
    function Backtrace1 
    {
        local _start_from_=0

        local params=( "$@" )
        if (( "${#params[@]}" >= "1" ))
        then
            _start_from_="$1"
        fi

        local i=0
        local first=false
        while caller $i > /dev/null
        do
            if test -n "$_start_from_" && (( "$i" + 1   >= "$_start_from_" ))
            then
                if test "$first" == false
                then
                    red "BACKTRACE IS:"
                    first=true
                fi
                caller $i
            fi
            let "i=i+1"
        done
        echo '_+_+_+_+_+'
    }
    take_photo(){
        echo4 "$last_camera_before" 
        pic_file=$(echo ~/pictures/webcam-$(date +%m_%d_%Y_%H_%M).jpeg)
        ffmpeg -y -r 1 -t 3 -f video4linux2 -vframes 1 -s sxga -i /dev/video0 $pic_file
        echo4 "$last_camera_after" 
        (xloadimage $pic_file &)
        (xloadimage $uml_pic &)
    }
    exiting()
    {
        #local file=$STATIC_DIR/exit.txt
        if [ "$VERBOSE" = true ];then
            Backtrace1
        fi


        red 'exiting!!'
        #echo 'exiting' | flite
        #choose4 $file

        remind_me_please 

        exit
    }
    remind_me_please(){
        #    red 'COMMANDS:'
        #    cat $DYNAMIC_DIR/learn/commands.txt
        #
        #    local command1=`cat $DYNAMIC_DIR/learn/commands.txt | head -1`
        #
        #    echo 'search google for the top command?'
        #    read answer
        #    if [ "$answer" = y ];then
        #        xdg-open http://google.com/${command1}
        #    fi
        #    white 'to be implemented: use url.txt'

        file=$DYNAMIC_DIR/day/plan.txt 
        str6=$( date | awk -F ' ' '{print $4}' )
        echo "$str6" >> $file 
        eacher     'gedit $file' 'show plan.txt?'
    }

    sleep1()
    {
        local sec="$1"
        local counter=0


        sleep "${sec}s"
    }

    log1()
    {
        str8=`echo "\t\t\t\tWORKFLOW";echo $workflow`
        str7=`echo "\t\t\t\tSPORT";cat  "$sport_txt" | head -2`
        str3=`cat  "$todo_txt" | head -2`
        str6=$( date | awk -F ' ' '{print $4}' )
        str5=`cat  "$timing_txt"  | head -3`
        str4=`cat  "$done_txt" | head -2` #points
        str1=""
        str2=$( white "\t\t\t\t\t\t\t$str6";  yellow "$str4"; green "$str3"; red "$str5";red "$str7";cyan "$str8" )
        echo "$str2"
    }
    log2(){

        str9=`cat  "$glossary_txt"  | head -3`
        str8=`cat  "$product_txt"  | head -3`
        str7=`cat  "$motivations_txt" | head -3 `

        str2=$( cyan "$str7"; white "$str8" ;green "$str9" )

        echo "$str2"
    }



    log3(){
        str=`cat  "$commitment_txt"`
        str2=$( white "$str"; )
        echo "$str2"

    }




    ##########################################tts engine
    #http://www.thegeekstuff.com/2010/03/espeak-speech-synthesizer-for-ubuntu/

    ##########################################vim:
    #:set filetype=sh #for identation, patern matching
    #:set syntax=sh
    #,ic - comment multiple lines

    ####################################local tts engines:
    #echo 'Вы можете играть с ним ?' | espeak -v ru -s 14
    #echo "russian words" | festival --tts --language russian

    ############## commands to remember:
    #1.mpack,2.sendmail /etc/ssmtp/ssmtp.conf -> update password


    update_lang(){
        export LANG=$1
        red "update translated language to: $LANG"
    }
    export LANG=''
    god(){
        white "$1"
    }
    robot(){
        cyan "robot:"
        white "$1"
    }
    me(){
        green "$1"
    }
    profit(){
        if [  "$PROFIT" = true ];then
            choose5 $STORY_DIR/wish.txt
        fi
    }

    update_file(){
        echo "update_file got: file: $1 | msg: $2 | $3"
        local file="$1"
        local msg="$2"
        #`echo $2`
        if [ "$msg" != '' ];then
            if [  "$PROFIT" = true ];then
                echo5 "$msg"
            fi
            cat $file > /tmp/1.txt 
            echo "$msg" > $file
            cat /tmp/1.txt >> $file
        fi
    }

    pids1(){
        echo "pids() got: $1"
        PIDS=$(pidof sh $1)  # Process IDs of the various instances of this script.
        #kill $PIDS
        P_array=( $PIDS )    # Put them in an array (why?).
        echo "$PIDS"           # Show process IDs of parent and child processes.
        let "instances = ${#P_array[*]} - 1"  # Count elements, less 1.
        # Why subtract 1?
        echo "$instances instance(s) of this script running."


        if [ $instances -gt 2 ];then
            #exiting
            red 'u may like to kill some..'
            echo 'too many instances are running' | flite
            #exiting
            #suspension

            exit 1
        fi

    }

    random_quote1(){
        file="$1"
        max=`cat -b $file | wc -l`
        random1 $max
        num=$?
        str=`cat $file | head -$num | tail -1`
        echo5 "$str" 

    }

    lower() { echo ${@,,}; }

    higher() { echo ${@^^}; }



    add_line(){
        echo2 "input line got: file:$1 title:$2 3:$3"
        #latest modifications: 
        #pass reference by supplying name of global variable.
        local file=$1
        local title="$2"
        local when="$3"
        answer=$( gxmessage  -title "$title" -file  "$file" -ontop -timeout 10 -entry )
        if [ "$answer" = exit ]
        then
            exiting
        fi
        if [ $TRANSLATE = true ]
        then
            str=`cat $file | head -1`
            #echo4 "$answer" 
        fi

        if [ "$when" = 'true' ];then
            date1="$(date +%H:%M)"
            str="$date1 - $answer"
        else
            str="$answer"
        fi

        update_file $file "$str"
    }

    split1(){
        echo '' > /tmp/glossary.txt
        echo2 'split()'
        local file=$1
        #cat $file
        old_IFS=$IFS
        IFS=$' · '
        lines=($(cat $file)) # array
        IFS=$old_IFS
        #register signals
        for line in "${lines[@]}"
        do
            if [ "$line" != '' ]
            then
                echo  "$line" >> /tmp/glossary.txt
            fi
        done
        cat  /tmp/glossary.txt 
        ls -l $file
    }

    eacher(){
        echo2  "eacher() got: 1: $1     2: $2"
        local question="$2"
        local command="$1"
        if [ "$EMPATHIC" = true ];then
            messageYN "y/n question" "$question"
            answer=$?
            yellow "$answer"
            if [[ $answer -eq 2 ]];then
                echo 'exec command'
                eval "$command" 
            fi
        else
            echo 'exec command'
            eval "$command" 

        fi





    }

    trap "eval exiting" SIGINT SIGTERM



    export -f eacher 
    export -f split1
    export -f random_quote1
    export -f update_lang 
    export -f update_file
    export -f god 
    export -f robot 
    export -f me 

    export -f echo1 
    export -f echo3 
    export -f echo2 

    export -f exiting
    export -f log1 
    export -f sleep1
    export -f messageYN 


    export -f green
    export -f red 
    export -f blue
    export -f yellow
    export -f Backtrace1

    #latest



    export -f is_valid 
    export -f take_photo 
    export -f spell1 

    export -f add_line 
    export -f pids1 

    #installation
    export motivations_txt="$STATIC_DIR/motivations.txt"
    #



    export dir_txt=$PRIVATE_DIR/tmp/txt
    #export done_txt=$REPORT_DIR/done.txt
    #export ideas_txt=$REPORT_DIR/ideas.txt
    #export now_txt=$REPORT_DIR/now.txt
    #export scrap_txt=$REPORT_DIR/scrap.txt
    #export log_txt=/tmp/log.txt
    #
    if [ "$INSTALL" = true ];then
        #    touch $ideas_txt
        #    touch $done_txt
        #    touch $now_txt
        #    touch $scrap_txt
        #
        #touch $log_txt
        mkdir -p $dir_txt
    fi




