{"version":3,"file":"/packages/spiderable.js","sources":["spiderable/spiderable.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,2B;AACA,iD;AACA,6C;AACA,mC;;AAEA,gB;;AAEA,mE;AACA,+D;AACA,gE;AACA,wC;AACA,E;AACA,kE;AACA,qE;AACA,iE;AACA,8B;AACA,+B;AACA,8D;;AAEA,kD;AACA,8B;;AAEA,sD;AACA,gD;AACA,wD;AACA,wD;;AAEA,0D;AACA,6C;AACA,yD;AACA,6C;AACA,sD;AACA,0E;AACA,qD;;AAEA,2E;AACA,8E;AACA,sE;AACA,6E;AACA,0E;AACA,Y;AACA,kE;AACA,qD;AACA,6B;AACA,sC;AACA,uD;AACA,oD;AACA,+D;AACA,qD;AACA,iC;AACA,wD;AACA,mB;AACA,+B;AACA,mB;AACA,4B;AACA,yC;AACA,uF;AACA,kF;AACA,mC;AACA,iC;AACA,iB;AACA,uB;;AAEA,qB;AACA,M;AACA,sE;AACA,iE;AACA,+C;AACA,M;AACA,oE;AACA,2E;AACA,6E;AACA,wE;AACA,6E;AACA,kB;AACA,2B;AACA,kB;AACA,Y;AACA,gE;AACA,kC;AACA,iC;AACA,wC;AACA,8C;AACA,2E;AACA,0B;AACA,gB;AACA,qE;AACA,yB;AACA,0C;AACA,kH;AACA,c;AACA,uF;;AAEA,iB;AACA,S;AACA,S;AACA,U;AACA,W;AACA,G;AACA,G","sourcesContent":["var fs = Npm.require('fs');\nvar child_process = Npm.require('child_process');\nvar querystring = Npm.require('querystring');\nvar urlParser = Npm.require('url');\n\nSpiderable = {};\n\n// list of bot user agents that we want to serve statically, but do\n// not obey the _escaped_fragment_ protocol. The page is served\n// statically to any client whos user agent matches any of these\n// regexps. Users may modify this array.\n//\n// An original goal with the spiderable package was to avoid doing\n// user-agent based tests. But the reality is not enough bots support\n// the _escaped_fragment_ protocol, so we need to hardcode a list\n// here. I shed a silent tear.\nSpiderable.userAgentRegExps = [\n    /^facebookexternalhit/i, /^linkedinbot/i, /^twitterbot/i];\n\n// how long to let phantomjs run before we kill it\nvar REQUEST_TIMEOUT = 15*1000;\n\nWebApp.connectHandlers.use(function (req, res, next) {\n  if (/\\?.*_escaped_fragment_=/.test(req.url) ||\n      _.any(Spiderable.userAgentRegExps, function (re) {\n        return re.test(req.headers['user-agent']); })) {\n\n    // reassembling url without escaped fragment if exists\n    var parsedUrl = urlParser.parse(req.url);\n    var parsedQuery = querystring.parse(parsedUrl.query);\n    delete parsedQuery['_escaped_fragment_'];\n    var newQuery = querystring.stringify(parsedQuery);\n    var newPath = parsedUrl.pathname + (newQuery ? ('?' + newQuery) : '');\n    var url = \"http://\" + req.headers.host + newPath;\n\n    // This string is going to be put into a bash script, so it's important\n    // that 'url' (which comes from the network) can neither exploit phantomjs\n    // or the bash script. JSON stringification should prevent it from\n    // exploiting phantomjs, and since the output of JSON.stringify shouldn't\n    // be able to contain newlines, it should be unable to exploit bash as\n    // well.\n    var phantomScript = \"var url = \" + JSON.stringify(url) + \";\" +\n          \"var page = require('webpage').create();\" +\n          \"page.open(url);\" +\n          \"setInterval(function() {\" +\n          \"  var ready = page.evaluate(function () {\" +\n          \"    if (typeof Meteor !== 'undefined' \" +\n          \"        && typeof(Meteor.status) !== 'undefined' \" +\n          \"        && Meteor.status().connected) {\" +\n          \"      Deps.flush();\" +\n          \"      return DDP._allSubscriptionsReady();\" +\n          \"    }\" +\n          \"    return false;\" +\n          \"  });\" +\n          \"  if (ready) {\" +\n          \"    var out = page.content;\" +\n          \"    out = out.replace(/<script[^>]+>(.|\\\\n|\\\\r)*?<\\\\/script\\\\s*>/ig, '');\" +\n          \"    out = out.replace('<meta name=\\\"fragment\\\" content=\\\"!\\\">', '');\" +\n          \"    console.log(out);\" +\n          \"    phantom.exit();\" +\n          \"  }\" +\n          \"}, 100);\\n\";\n\n    // Run phantomjs.\n    //\n    // Use '/dev/stdin' to avoid writing to a temporary file. We can't\n    // just omit the file, as PhantomJS takes that to mean 'use a\n    // REPL' and exits as soon as stdin closes.\n    //\n    // However, Node 0.8 broke the ability to open /dev/stdin in the\n    // subprocess, so we can't just write our string to the process's stdin\n    // directly; see https://gist.github.com/3751746 for the gory details. We\n    // work around this with a bash heredoc. (We previous used a \"cat |\"\n    // instead, but that meant we couldn't use exec and had to manage several\n    // processes.)\n    child_process.execFile(\n      '/bin/bash',\n      ['-c',\n       (\"exec phantomjs --load-images=no /dev/stdin <<'END'\\n\" +\n        phantomScript + \"END\\n\")],\n      {timeout: REQUEST_TIMEOUT},\n      function (error, stdout, stderr) {\n        if (!error && /<html/i.test(stdout)) {\n          res.writeHead(200, {'Content-Type': 'text/html; charset=UTF-8'});\n          res.end(stdout);\n        } else {\n          // phantomjs failed. Don't send the error, instead send the\n          // normal page.\n          if (error && error.code === 127)\n            Meteor._debug(\"spiderable: phantomjs not installed. Download and install from http://phantomjs.org/\");\n          else\n            Meteor._debug(\"spiderable: phantomjs failed:\", error, \"\\nstderr:\", stderr);\n\n          next();\n        }\n      });\n  } else {\n    next();\n  }\n});\n"]}