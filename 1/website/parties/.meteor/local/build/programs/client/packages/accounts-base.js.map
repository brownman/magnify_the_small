)]}'
{"version":3,"file":"/packages/accounts-base.js","sources":["accounts-base/accounts_common.js","accounts-base/url_client.js","accounts-base/accounts_client.js","accounts-base/localstorage_token.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,c;;AAEA,qE;AACA,4B;AACA,uB;;AAEA,sE;AACA,kB;AACA,E;AACA,qE;AACA,+C;AACA,sE;AACA,oE;AACA,qD;AACA,E;AACA,iD;AACA,oC;AACA,uE;AACA,sB;AACA,0C;AACA,wD;AACA,E;AACA,qC;AACA,yB;AACA,4E;AACA,0C;AACA,uC;AACA,8D;AACA,K;AACA,K;;AAEA,oC;AACA,qC;AACA,yB;AACA,qC;AACA,kE;AACA,c;AACA,8C;AACA,O;AACA,K;AACA,K;AACA,E;;AAEA,uE;AACA,kE;AACA,qD;AACA,E;AACA,2E;AACA,gE;AACA,c;;AAEA,uF;AACA,yE;AACA,wD;;AAEA,sE;AACA,oC;AACA,sD;AACA,6B;AACA,E;;AAEA,6E;AACA,6E;AACA,oC;AACA,sD;AACA,qD;AACA,6E;;;;;;;;;;;;;;;;;;;;AClEA,wB;;AAEA,qE;AACA,kE;AACA,mE;AACA,S;AACA,E;AACA,oE;AACA,qE;AACA,sB;AACA,U;AACA,iE;AACA,Y;AACA,2B;AACA,0C;AACA,4B;AACA,C;;AAEA,8D;AACA,gE;AACA,wB;AACA,E;AACA,mE;AACA,oE;AACA,+D;AACA,+D;AACA,kE;AACA,2C;AACA,+D;AACA,Y;AACA,2B;AACA,wC;AACA,4B;AACA,C;;AAEA,qE;AACA,gE;AACA,wB;AACA,iE;AACA,Y;AACA,2B;AACA,0C;AACA,4B;AACA,C;;;;;;;;;;;;;;;;;;;AC3CA,G;AACA,gB;AACA,G;;AAEA,oB;AACA,6B;AACA,oC;AACA,E;;AAEA,sB;AACA,wC;AACA,4E;AACA,4E;AACA,mB;AACA,uC;AACA,wB;AACA,kB;AACA,4B;AACA,G;AACA,E;AACA,gC;AACA,yB;AACA,mB;AACA,E;;AAEA,wC;AACA,2B;AACA,+B;AACA,c;AACA,gB;AACA,sC;AACA,E;;AAEA,G;AACA,iB;AACA,G;;AAEA,qC;AACA,E;AACA,4E;AACA,6E;AACA,2C;AACA,E;AACA,+B;AACA,2D;AACA,wC;AACA,0D;AACA,wD;AACA,2D;AACA,uB;AACA,E;AACA,W;AACA,qD;AACA,kD;AACA,uE;AACA,8E;AACA,6D;AACA,0E;AACA,yD;AACA,E;AACA,+C;AACA,sB;AACA,wB;AACA,wB;AACA,6B;AACA,c;AACA,yE;AACA,gC;AACA,2D;AACA,oB;AACA,kC;AACA,K;;AAEA,0B;;AAEA,6E;AACA,2E;AACA,0E;AACA,wE;AACA,2E;AACA,yE;AACA,yE;AACA,0C;AACA,I;AACA,0E;AACA,4E;AACA,4E;AACA,2E;AACA,gE;AACA,iD;AACA,0C;AACA,2C;AACA,Y;AACA,kD;AACA,2B;AACA,kC;AACA,oD;AACA,sE;AACA,6E;AACA,iD;AACA,mC;AACA,0C;AACA,wB;AACA,oC;AACA,a;AACA,wC;AACA,c;AACA,Q;AACA,K;AACA,I;;AAEA,qE;AACA,6E;AACA,U;AACA,+D;AACA,wE;AACA,2E;AACA,2E;AACA,yD;AACA,0E;AACA,oB;AACA,a;;AAEA,yE;AACA,gE;AACA,iD;AACA,kC;AACA,2B;AACA,iC;AACA,wD;AACA,kC;AACA,a;AACA,K;AACA,S;AACA,qC;AACA,iB;AACA,8B;AACA,a;AACA,K;;AAEA,2E;AACA,gD;AACA,2B;AACA,I;;AAEA,kC;AACA,iC;AACA,e;AACA,uB;AACA,4B;AACA,qD;AACA,kC;AACA,E;;AAEA,kC;AACA,sB;AACA,oC;AACA,uC;AACA,E;;AAEA,8C;AACA,iC;AACA,sC;AACA,E;;AAEA,qC;AACA,oE;AACA,gB;AACA,kC;AACA,Y;AACA,4B;AACA,6B;AACA,K;AACA,K;AACA,E;;AAEA,G;AACA,kB;AACA,G;;AAEA,+E;;AAEA,sE;AACA,sE;AACA,6C;AACA,E;AACA,gD;AACA,qC;AACA,E;;AAEA,G;AACA,sB;AACA,G;;AAEA,8D;AACA,gC;AACA,yB;AACA,2E;AACA,yB;AACA,K;AACA,yE;AACA,8B;AACA,K;AACA,C;;;;;;;;;;;;;;;;;;;AC3MA,gE;AACA,oE;AACA,uE;AACA,W;;AAEA,6B;;AAEA,qE;AACA,Q;AACA,oD;AACA,4B;AACA,uC;AACA,6B;AACA,E;;AAEA,sE;AACA,iC;AACA,yC;AACA,0B;AACA,yB;AACA,E;;;AAGA,G;AACA,W;AACA,G;;AAEA,mC;AACA,wC;AACA,gC;;AAEA,uE;AACA,sE;AACA,kE;AACA,kD;AACA,8C;AACA,sC;AACA,E;;AAEA,2C;AACA,kD;AACA,qD;;AAEA,oE;AACA,0B;AACA,mC;AACA,E;;AAEA,gC;AACA,6C;AACA,iD;;AAEA,oE;AACA,0B;AACA,kC;AACA,E;;AAEA,sE;AACA,6B;AACA,E;AACA,gE;AACA,qD;AACA,E;;AAEA,+B;AACA,iD;AACA,E;;;AAGA,G;AACA,c;AACA,G;;AAEA,uB;AACA,iE;AACA,iE;AACA,iC;AACA,c;AACA,mE;AACA,kE;AACA,gC;AACA,kD;AACA,iD;AACA,gB;AACA,6D;AACA,8B;AACA,O;AACA,O;AACA,G;AACA,C;;AAEA,sE;AACA,c;AACA,iC;AACA,uC;AACA,yB;AACA,W;;AAEA,6C;;AAEA,gF;AACA,sD;AACA,0B;AACA,sF;AACA,Q;AACA,sB;AACA,G;AACA,+C;AACA,E;;AAEA,wC","sourcesContent":["Accounts = {};\n\n// Currently this is read directly by packages like accounts-password\n// and accounts-ui-unstyled.\nAccounts._options = {};\n\n// Set up config for the accounts system. Call this on both the client\n// and the server.\n//\n// XXX we should add some enforcement that this is called on both the\n// client and the server. Otherwise, a user can\n// 'forbidClientAccountCreation' only on the client and while it looks\n// like their app is secure, the server will still accept createUser\n// calls. https://github.com/meteor/meteor/issues/828\n//\n// @param options {Object} an object with fields:\n// - sendVerificationEmail {Boolean}\n//     Send email address verification emails to new users created from\n//     client signups.\n// - forbidClientAccountCreation {Boolean}\n//     Do not allow clients to create accounts directly.\n//\nAccounts.config = function(options) {\n  // validate option keys\n  var VALID_KEYS = [\"sendVerificationEmail\", \"forbidClientAccountCreation\"];\n  _.each(_.keys(options), function (key) {\n    if (!_.contains(VALID_KEYS, key)) {\n      throw new Error(\"Accounts.config: Invalid key: \" + key);\n    }\n  });\n\n  // set values in Accounts._options\n  _.each(VALID_KEYS, function (key) {\n    if (key in options) {\n      if (key in Accounts._options) {\n        throw new Error(\"Can't set `\" + key + \"` more than once\");\n      } else {\n        Accounts._options[key] = options[key];\n      }\n    }\n  });\n};\n\n// Users table. Don't use the normal autopublish, since we want to hide\n// some fields. Code to autopublish this is in accounts_server.js.\n// XXX Allow users to configure this collection name.\n//\nMeteor.users = new Meteor.Collection(\"users\", {_preventAutopublish: true});\n// There is an allow call in accounts_server that restricts this\n// collection.\n\n// loginServiceConfiguration and ConfigError are maintained for backwards compatibility\nAccounts.loginServiceConfiguration = ServiceConfiguration.configurations;\nAccounts.ConfigError = ServiceConfiguration.ConfigError;\n\n// Thrown when the user cancels the login process (eg, closes an oauth\n// popup, declines retina scan, etc)\nAccounts.LoginCancelledError = function(description) {\n  this.message = description;\n};\n\n// This is used to transmit specific subclass errors over the wire. We should\n// come up with a more generic way to do this (eg, with some sort of symbolic\n// error code rather than a number).\nAccounts.LoginCancelledError.numericError = 0x8acdc2f;\nAccounts.LoginCancelledError.prototype = new Error();\nAccounts.LoginCancelledError.prototype.name = 'Accounts.LoginCancelledError';\n\n","autoLoginEnabled = true;\n\n// reads a reset password token from the url's hash fragment, if it's\n// there. if so prevent automatically logging in since it could be\n// confusing to be logged in as user A while resetting password for\n// user B\n//\n// reset password urls use hash fragments instead of url paths/query\n// strings so that the reset password token is not sent over the wire\n// on the http request\nvar match;\nmatch = window.location.hash.match(/^\\#\\/reset-password\\/(.*)$/);\nif (match) {\n  autoLoginEnabled = false;\n  Accounts._resetPasswordToken = match[1];\n  window.location.hash = '';\n}\n\n// reads a verify email token from the url's hash fragment, if\n// it's there.  also don't automatically log the user is, as for\n// reset password links.\n//\n// XXX we don't need to use hash fragments in this case, and having\n// the token appear in the url's path would allow us to use a custom\n// middleware instead of verifying the email on pageload, which\n// would be faster but less DDP-ish (and more specifically, any\n// non-web DDP app, such as an iOS client, would do something more\n// in line with the hash fragment approach)\nmatch = window.location.hash.match(/^\\#\\/verify-email\\/(.*)$/);\nif (match) {\n  autoLoginEnabled = false;\n  Accounts._verifyEmailToken = match[1];\n  window.location.hash = '';\n}\n\n// reads an account enrollment token from the url's hash fragment, if\n// it's there.  also don't automatically log the user is, as for\n// reset password links.\nmatch = window.location.hash.match(/^\\#\\/enroll-account\\/(.*)$/);\nif (match) {\n  autoLoginEnabled = false;\n  Accounts._enrollAccountToken = match[1];\n  window.location.hash = '';\n}\n","///\n/// CURRENT USER\n///\n\n// This is reactive.\nMeteor.userId = function () {\n  return Meteor.connection.userId();\n};\n\nvar loggingIn = false;\nvar loggingInDeps = new Deps.Dependency;\n// This is mostly just called within this file, but Meteor.loginWithPassword\n// also uses it to make loggingIn() be true during the beginPasswordExchange\n// method call too.\nAccounts._setLoggingIn = function (x) {\n  if (loggingIn !== x) {\n    loggingIn = x;\n    loggingInDeps.changed();\n  }\n};\nMeteor.loggingIn = function () {\n  loggingInDeps.depend();\n  return loggingIn;\n};\n\n// This calls userId, which is reactive.\nMeteor.user = function () {\n  var userId = Meteor.userId();\n  if (!userId)\n    return null;\n  return Meteor.users.findOne(userId);\n};\n\n///\n/// LOGIN METHODS\n///\n\n// Call a login method on the server.\n//\n// A login method is a method which on success calls `this.setUserId(id)` on\n// the server and returns an object with fields 'id' (containing the user id)\n// and 'token' (containing a resume token).\n//\n// This function takes care of:\n//   - Updating the Meteor.loggingIn() reactive data source\n//   - Calling the method in 'wait' mode\n//   - On success, saving the resume token to localStorage\n//   - On success, calling Meteor.connection.setUserId()\n//   - Setting up an onReconnect handler which logs in with\n//     the resume token\n//\n// Options:\n// - methodName: The method to call (default 'login')\n// - methodArguments: The arguments for the method\n// - validateResult: If provided, will be called with the result of the\n//                 method. If it throws, the client will not be logged in (and\n//                 its error will be passed to the callback).\n// - userCallback: Will be called with no arguments once the user is fully\n//                 logged in, or with the error on error.\n//\nAccounts.callLoginMethod = function (options) {\n  options = _.extend({\n    methodName: 'login',\n    methodArguments: [],\n    _suppressLoggingIn: false\n  }, options);\n  // Set defaults for callback arguments to no-op functions; make sure we\n  // override falsey values too.\n  _.each(['validateResult', 'userCallback'], function (f) {\n    if (!options[f])\n      options[f] = function () {};\n  });\n\n  var reconnected = false;\n\n  // We want to set up onReconnect as soon as we get a result token back from\n  // the server, without having to wait for subscriptions to rerun. This is\n  // because if we disconnect and reconnect between getting the result and\n  // getting the results of subscription rerun, we WILL NOT re-send this\n  // method (because we never re-send methods whose results we've received)\n  // but we WILL call loggedInAndDataReadyCallback at \"reconnect quiesce\"\n  // time. This will lead to makeClientLoggedIn(result.id) even though we\n  // haven't actually sent a login method!\n  //\n  // But by making sure that we send this \"resume\" login in that case (and\n  // calling makeClientLoggedOut if it fails), we'll end up with an accurate\n  // client-side userId. (It's important that livedata_connection guarantees\n  // that the \"reconnect quiesce\"-time call to loggedInAndDataReadyCallback\n  // will occur before the callback from the resume login call.)\n  var onResultReceived = function (err, result) {\n    if (err || !result || !result.token) {\n      Meteor.connection.onReconnect = null;\n    } else {\n      Meteor.connection.onReconnect = function() {\n        reconnected = true;\n        Accounts.callLoginMethod({\n          methodArguments: [{resume: result.token}],\n          // Reconnect quiescence ensures that the user doesn't see an\n          // intermediate state before the login method finishes. So we don't\n          // need to show a logging-in animation.\n          _suppressLoggingIn: true,\n          userCallback: function (error) {\n            if (error) {\n              makeClientLoggedOut();\n            }\n            options.userCallback(error);\n          }});\n      };\n    }\n  };\n\n  // This callback is called once the local cache of the current-user\n  // subscription (and all subscriptions, in fact) are guaranteed to be up to\n  // date.\n  var loggedInAndDataReadyCallback = function (error, result) {\n    // If the login method returns its result but the connection is lost\n    // before the data is in the local cache, it'll set an onReconnect (see\n    // above). The onReconnect will try to log in using the token, and *it*\n    // will call userCallback via its own version of this\n    // loggedInAndDataReadyCallback. So we don't have to do anything here.\n    if (reconnected)\n      return;\n\n    // Note that we need to call this even if _suppressLoggingIn is true,\n    // because it could be matching a _setLoggingIn(true) from a\n    // half-completed pre-reconnect login method.\n    Accounts._setLoggingIn(false);\n    if (error || !result) {\n      error = error || new Error(\n        \"No result from call to \" + options.methodName);\n      options.userCallback(error);\n      return;\n    }\n    try {\n      options.validateResult(result);\n    } catch (e) {\n      options.userCallback(e);\n      return;\n    }\n\n    // Make the client logged in. (The user data should already be loaded!)\n    makeClientLoggedIn(result.id, result.token);\n    options.userCallback();\n  };\n\n  if (!options._suppressLoggingIn)\n    Accounts._setLoggingIn(true);\n  Meteor.apply(\n    options.methodName,\n    options.methodArguments,\n    {wait: true, onResultReceived: onResultReceived},\n    loggedInAndDataReadyCallback);\n};\n\nmakeClientLoggedOut = function() {\n  unstoreLoginToken();\n  Meteor.connection.setUserId(null);\n  Meteor.connection.onReconnect = null;\n};\n\nmakeClientLoggedIn = function(userId, token) {\n  storeLoginToken(userId, token);\n  Meteor.connection.setUserId(userId);\n};\n\nMeteor.logout = function (callback) {\n  Meteor.apply('logout', [], {wait: true}, function(error, result) {\n    if (error) {\n      callback && callback(error);\n    } else {\n      makeClientLoggedOut();\n      callback && callback();\n    }\n  });\n};\n\n///\n/// LOGIN SERVICES\n///\n\nvar loginServicesHandle = Meteor.subscribe(\"meteor.loginServiceConfiguration\");\n\n// A reactive function returning whether the loginServiceConfiguration\n// subscription is ready. Used by accounts-ui to hide the login button\n// until we have all the configuration loaded\n//\nAccounts.loginServicesConfigured = function () {\n  return loginServicesHandle.ready();\n};\n\n///\n/// HANDLEBARS HELPERS\n///\n\n// If we're using Handlebars, register the {{currentUser}} and\n// {{loggingIn}} global helpers.\nif (Package.handlebars) {\n  Package.handlebars.Handlebars.registerHelper('currentUser', function () {\n    return Meteor.user();\n  });\n  Package.handlebars.Handlebars.registerHelper('loggingIn', function () {\n    return Meteor.loggingIn();\n  });\n}\n","// This file deals with storing a login token and user id in the\n// browser's localStorage facility. It polls local storage every few\n// seconds to synchronize login state between multiple tabs in the same\n// browser.\n\nvar lastLoginTokenWhenPolled;\n\n// Login with a Meteor access token. This is the only public function\n// here.\nMeteor.loginWithToken = function (token, callback) {\n  Accounts.callLoginMethod({\n    methodArguments: [{resume: token}],\n    userCallback: callback});\n};\n\n// Semi-internal API. Call this function to re-enable auto login after\n// if it was disabled at startup.\nAccounts._enableAutoLogin = function () {\n  autoLoginEnabled = true;\n  pollStoredLoginToken();\n};\n\n\n///\n/// STORING\n///\n\n// Key names to use in localStorage\nvar loginTokenKey = \"Meteor.loginToken\";\nvar userIdKey = \"Meteor.userId\";\n\n// Call this from the top level of the test file for any test that does\n// logging in and out, to protect multiple tabs running the same tests\n// simultaneously from interfering with each others' localStorage.\nAccounts._isolateLoginTokenForTest = function () {\n  loginTokenKey = loginTokenKey + Random.id();\n  userIdKey = userIdKey + Random.id();\n};\n\nstoreLoginToken = function(userId, token) {\n  Meteor._localStorage.setItem(userIdKey, userId);\n  Meteor._localStorage.setItem(loginTokenKey, token);\n\n  // to ensure that the localstorage poller doesn't end up trying to\n  // connect a second time\n  lastLoginTokenWhenPolled = token;\n};\n\nunstoreLoginToken = function() {\n  Meteor._localStorage.removeItem(userIdKey);\n  Meteor._localStorage.removeItem(loginTokenKey);\n\n  // to ensure that the localstorage poller doesn't end up trying to\n  // connect a second time\n  lastLoginTokenWhenPolled = null;\n};\n\n// This is private, but it is exported for now because it is used by a\n// test in accounts-password.\n//\nvar storedLoginToken = Accounts._storedLoginToken = function() {\n  return Meteor._localStorage.getItem(loginTokenKey);\n};\n\nvar storedUserId = function() {\n  return Meteor._localStorage.getItem(userIdKey);\n};\n\n\n///\n/// AUTO-LOGIN\n///\n\nif (autoLoginEnabled) {\n  // Immediately try to log in via local storage, so that any DDP\n  // messages are sent after we have established our user account\n  var token = storedLoginToken();\n  if (token) {\n    // On startup, optimistically present us as logged in while the\n    // request is in flight. This reduces page flicker on startup.\n    var userId = storedUserId();\n    userId && Meteor.connection.setUserId(userId);\n    Meteor.loginWithToken(token, function (err) {\n      if (err) {\n        Meteor._debug(\"Error logging in with token: \" + err);\n        makeClientLoggedOut();\n      }\n    });\n  }\n}\n\n// Poll local storage every 3 seconds to login if someone logged in in\n// another tab\nlastLoginTokenWhenPolled = token;\nvar pollStoredLoginToken = function() {\n  if (! autoLoginEnabled)\n    return;\n\n  var currentLoginToken = storedLoginToken();\n\n  // != instead of !== just to make sure undefined and null are treated the same\n  if (lastLoginTokenWhenPolled != currentLoginToken) {\n    if (currentLoginToken)\n      Meteor.loginWithToken(currentLoginToken); // XXX should we pass a callback here?\n    else\n      Meteor.logout();\n  }\n  lastLoginTokenWhenPolled = currentLoginToken;\n};\n\nsetInterval(pollStoredLoginToken, 3000);\n"]}