{"version":3,"file":"/packages/accounts-base.js","sources":["accounts-base/accounts_common.js","accounts-base/accounts_server.js","accounts-base/url_server.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA,c;;AAEA,qE;AACA,4B;AACA,uB;;AAEA,sE;AACA,kB;AACA,E;AACA,qE;AACA,+C;AACA,sE;AACA,oE;AACA,qD;AACA,E;AACA,iD;AACA,oC;AACA,uE;AACA,sB;AACA,0C;AACA,wD;AACA,E;AACA,qC;AACA,yB;AACA,4E;AACA,0C;AACA,uC;AACA,8D;AACA,K;AACA,K;;AAEA,oC;AACA,qC;AACA,yB;AACA,qC;AACA,kE;AACA,c;AACA,8C;AACA,O;AACA,K;AACA,K;AACA,E;;AAEA,uE;AACA,kE;AACA,qD;AACA,E;AACA,2E;AACA,gE;AACA,c;;AAEA,uF;AACA,yE;AACA,wD;;AAEA,sE;AACA,oC;AACA,sD;AACA,6B;AACA,E;;AAEA,6E;AACA,6E;AACA,oC;AACA,sD;AACA,qD;AACA,6E;;;;;;;;;;;;;;;;;;;;AClEA,G;AACA,gB;AACA,G;;AAEA,6B;AACA,sE;AACA,kE;AACA,oE;AACA,gE;AACA,kE;AACA,mE;AACA,kE;AACA,mE;AACA,oB;AACA,uD;AACA,yB;AACA,gH;AACA,kC;AACA,E;;AAEA,2B;AACA,+B;AACA,c;AACA,gB;AACA,sC;AACA,E;;AAEA,G;AACA,kB;AACA,G;;AAEA,8D;AACA,E;AACA,uE;AACA,uE;AACA,uC;AACA,gE;AACA,kD;AACA,E;AACA,mD;AACA,8B;AACA,E;;AAEA,mC;AACA,mB;;;AAGA,oE;AACA,sE;AACA,0D;AACA,8C;AACA,kD;AACA,mC;AACA,kC;AACA,6B;AACA,oB;AACA,G;;AAEA,wE;AACA,E;;;AAGA,mE;AACA,8B;AACA,gB;AACA,2B;AACA,iE;AACA,+E;AACA,qB;AACA,4B;AACA,6E;AACA,wC;AACA,2B;AACA,8C;AACA,0B;AACA,gC;AACA,kD;AACA,K;AACA,kB;AACA,I;;AAEA,sB;AACA,oD;AACA,kE;AACA,yB;AACA,G;AACA,G;;AAEA,G;AACA,oB;AACA,G;AACA,mD;;AAEA,mC;AACA,iD;AACA,sB;AACA,qB;;AAEA,gC;AACA,mC;AACA,0D;AACA,K;AACA,Y;AACA,6D;;AAEA,U;AACA,0B;AACA,gB;AACA,I;AACA,G;;AAEA,+D;AACA,E;AACA,mD;AACA,iD;AACA,E;;AAEA,kD;AACA,+B;AACA,Y;AACA,4D;AACA,K;AACA,K;AACA,E;;;AAGA,G;AACA,qB;AACA,G;;AAEA,4B;AACA,yC;AACA,uB;AACA,uD;AACA,M;AACA,4B;AACA,E;;AAEA,4E;AACA,oC;AACA,sD;AACA,sB;AACA,mC;AACA,c;AACA,E;;AAEA,8B;AACA,mD;AACA,wD;AACA,8B;AACA,mE;AACA,4C;AACA,I;AACA,oE;AACA,iD;AACA,mE;AACA,iE;AACA,kE;AACA,iE;AACA,iB;AACA,oE;;AAEA,kB;AACA,mC;AACA,6D;AACA,sC;AACA,+C;AACA,mD;AACA,0D;AACA,Q;AACA,wD;AACA,G;;AAEA,e;AACA,yB;AACA,+C;;AAEA,2E;AACA,yE;AACA,iE;AACA,yC;AACA,sD;AACA,U;AACA,oD;AACA,G;;AAEA,gD;AACA,wB;AACA,4D;AACA,K;;AAEA,O;AACA,8C;AACA,e;AACA,sC;AACA,yE;AACA,yC;AACA,0E;AACA,wB;AACA,mD;AACA,2D;AACA,4C;AACA,8D;AACA,yE;AACA,Y;AACA,G;;AAEA,gB;AACA,E;;AAEA,8B;AACA,4C;AACA,kC;AACA,E;;;AAGA,G;AACA,yB;AACA,G;;AAEA,oE;AACA,E;AACA,0D;AACA,iE;AACA,iE;AACA,mE;AACA,2E;AACA,uB;AACA,mE;AACA,gC;AACA,E;AACA,0D;AACA,sC;AACA,mC;;AAEA,6D;AACA,oB;AACA,8E;AACA,uB;AACA,gC;AACA,oB;AACA,sE;;AAEA,0D;AACA,oB;AACA,uD;;AAEA,yD;AACA,wE;AACA,wE;AACA,qE;AACA,4E;AACA,6E;AACA,sE;AACA,4D;AACA,8B;AACA,sD;AACA,oE;AACA,U;AACA,4C;AACA,G;;AAEA,4C;;AAEA,a;AACA,6E;AACA,yE;AACA,6D;AACA,mE;AACA,0B;AACA,6D;AACA,sB;AACA,8C;AACA,8D;AACA,O;;AAEA,6E;AACA,2B;AACA,wB;AACA,e;AACA,sB;AACA,8D;AACA,qD;AACA,U;AACA,6E;AACA,qB;AACA,0B;AACA,6C;AACA,sC;AACA,iD;AACA,G;AACA,E;;;AAGA,G;AACA,mB;AACA,G;;AAEA,mD;AACA,iC;AACA,oB;AACA,6B;AACA,yB;AACA,sD;AACA,U;AACA,gB;AACA,G;AACA,oD;;AAEA,iE;AACA,wD;AACA,qE;AACA,iE;AACA,kE;AACA,yB;AACA,kD;AACA,qC;AACA,E;;AAEA,6D;AACA,gE;AACA,8C;AACA,E;AACA,6B;AACA,8E;AACA,qF;AACA,gD;AACA,4C;AACA,0D;AACA,0C;AACA,sD;AACA,E;;AAEA,0B;AACA,+D;AACA,0B;AACA,8B;AACA,2D;AACA,4C;AACA,qD;AACA,0B;AACA,U;AACA,M;;AAEA,6C;AACA,wB;AACA,iC;AACA,6B;AACA,qE;AACA,c;AACA,oB;AACA,O;AACA,wD;;AAEA,gF;AACA,8E;AACA,6E;AACA,+E;AACA,gE;AACA,6C;AACA,mB;AACA,sB;AACA,6C;AACA,U;AACA,sB;;AAEA,+B;AACA,iB;AACA,iE;AACA,wD;AACA,K;AACA,C;;AAEA,oE;AACA,gE;AACA,6E;AACA,2E;;AAEA,oE;AACA,wD;AACA,gB;AACA,+C;AACA,6D;AACA,0E;AACA,yE;AACA,wB;AACA,2E;AACA,wE;AACA,0B;AACA,wB;AACA,2E;AACA,qD;AACA,K;AACA,gF;AACA,wF;AACA,wD;AACA,G;AACA,G;;;AAGA,G;AACA,sC;AACA,G;;AAEA,oB;AACA,oE;AACA,kB;AACA,qD;AACA,iC;AACA,4B;AACA,mB;;AAEA,iE;AACA,sE;AACA,0B;AACA,uD;AACA,mB;;AAEA,gB;AACA,I;AACA,wC;AACA,G;;AAEA,4B;AACA,8D;AACA,oE;AACA,8D;AACA,kD;;;;;;;;;;;;;;;;;;;AC3aA,oD;;AAEA,mB;;AAEA,gD;AACA,yD;AACA,E;;AAEA,8C;AACA,uD;AACA,E;;AAEA,gD;AACA,yD;AACA,E","sourcesContent":["Accounts = {};\n\n// Currently this is read directly by packages like accounts-password\n// and accounts-ui-unstyled.\nAccounts._options = {};\n\n// Set up config for the accounts system. Call this on both the client\n// and the server.\n//\n// XXX we should add some enforcement that this is called on both the\n// client and the server. Otherwise, a user can\n// 'forbidClientAccountCreation' only on the client and while it looks\n// like their app is secure, the server will still accept createUser\n// calls. https://github.com/meteor/meteor/issues/828\n//\n// @param options {Object} an object with fields:\n// - sendVerificationEmail {Boolean}\n//     Send email address verification emails to new users created from\n//     client signups.\n// - forbidClientAccountCreation {Boolean}\n//     Do not allow clients to create accounts directly.\n//\nAccounts.config = function(options) {\n  // validate option keys\n  var VALID_KEYS = [\"sendVerificationEmail\", \"forbidClientAccountCreation\"];\n  _.each(_.keys(options), function (key) {\n    if (!_.contains(VALID_KEYS, key)) {\n      throw new Error(\"Accounts.config: Invalid key: \" + key);\n    }\n  });\n\n  // set values in Accounts._options\n  _.each(VALID_KEYS, function (key) {\n    if (key in options) {\n      if (key in Accounts._options) {\n        throw new Error(\"Can't set `\" + key + \"` more than once\");\n      } else {\n        Accounts._options[key] = options[key];\n      }\n    }\n  });\n};\n\n// Users table. Don't use the normal autopublish, since we want to hide\n// some fields. Code to autopublish this is in accounts_server.js.\n// XXX Allow users to configure this collection name.\n//\nMeteor.users = new Meteor.Collection(\"users\", {_preventAutopublish: true});\n// There is an allow call in accounts_server that restricts this\n// collection.\n\n// loginServiceConfiguration and ConfigError are maintained for backwards compatibility\nAccounts.loginServiceConfiguration = ServiceConfiguration.configurations;\nAccounts.ConfigError = ServiceConfiguration.ConfigError;\n\n// Thrown when the user cancels the login process (eg, closes an oauth\n// popup, declines retina scan, etc)\nAccounts.LoginCancelledError = function(description) {\n  this.message = description;\n};\n\n// This is used to transmit specific subclass errors over the wire. We should\n// come up with a more generic way to do this (eg, with some sort of symbolic\n// error code rather than a number).\nAccounts.LoginCancelledError.numericError = 0x8acdc2f;\nAccounts.LoginCancelledError.prototype = new Error();\nAccounts.LoginCancelledError.prototype.name = 'Accounts.LoginCancelledError';\n\n","///\n/// CURRENT USER\n///\n\nMeteor.userId = function () {\n  // This function only works if called inside a method. In theory, it\n  // could also be called from publish statements, since they also\n  // have a userId associated with them. However, given that publish\n  // functions aren't reactive, using any of the infomation from\n  // Meteor.user() in a publish function will always use the value\n  // from when the function first runs. This is likely not what the\n  // user expects. The way to make this work in a publish is to do\n  // Meteor.find(this.userId()).observe and recompute when the user\n  // record changes.\n  var currentInvocation = DDP._CurrentInvocation.get();\n  if (!currentInvocation)\n    throw new Error(\"Meteor.userId can only be invoked in method calls. Use this.userId in publish functions.\");\n  return currentInvocation.userId;\n};\n\nMeteor.user = function () {\n  var userId = Meteor.userId();\n  if (!userId)\n    return null;\n  return Meteor.users.findOne(userId);\n};\n\n///\n/// LOGIN HANDLERS\n///\n\n// The main entry point for auth packages to hook in to login.\n//\n// @param handler {Function} A function that receives an options object\n// (as passed as an argument to the `login` method) and returns one of:\n// - `undefined`, meaning don't handle;\n// - {id: userId, token: *}, if the user logged in successfully.\n// - throw an error, if the user failed to log in.\n//\nAccounts.registerLoginHandler = function(handler) {\n  loginHandlers.push(handler);\n};\n\n// list of all registered handlers.\nloginHandlers = [];\n\n\n// Try all of the registered login handlers until one of them doesn'\n// return `undefined`, meaning it handled this call to `login`. Return\n// that return value, which ought to be a {id/token} pair.\nvar tryAllLoginHandlers = function (options) {\n  for (var i = 0; i < loginHandlers.length; ++i) {\n    var handler = loginHandlers[i];\n    var result = handler(options);\n    if (result !== undefined)\n      return result;\n  }\n\n  throw new Meteor.Error(400, \"Unrecognized options for login request\");\n};\n\n\n// Actual methods for login and logout. This is the entry point for\n// clients to actually log in.\nMeteor.methods({\n  // @returns {Object|null}\n  //   If successful, returns {token: reconnectToken, id: userId}\n  //   If unsuccessful (for example, if the user closed the oauth login popup),\n  //     returns null\n  login: function(options) {\n    // Login handlers should really also check whatever field they look at in\n    // options, but we don't enforce it.\n    check(options, Object);\n    var result = tryAllLoginHandlers(options);\n    if (result !== null) {\n      this.setUserId(result.id);\n      this._sessionData.loginToken = result.token;\n    }\n    return result;\n  },\n\n  logout: function() {\n    if (this._sessionData.loginToken && this.userId)\n      removeLoginToken(this.userId, this._sessionData.loginToken);\n    this.setUserId(null);\n  }\n});\n\n///\n/// RECONNECT TOKENS\n///\n/// support reconnecting using a meteor login token\n\n// Login handler for resume tokens.\nAccounts.registerLoginHandler(function(options) {\n  if (!options.resume)\n    return undefined;\n\n  check(options.resume, String);\n  var user = Meteor.users.findOne({\n    \"services.resume.loginTokens.token\": \"\"+options.resume\n  });\n  if (!user)\n    throw new Meteor.Error(403, \"Couldn't find login token\");\n\n  return {\n    token: options.resume,\n    id: user._id\n  };\n});\n\n// Semi-public. Used by other login methods to generate tokens.\n//\nAccounts._generateStampedLoginToken = function () {\n  return {token: Random.id(), when: +(new Date)};\n};\n\nremoveLoginToken = function (userId, loginToken) {\n  Meteor.users.update(userId, {\n    $pull: {\n      \"services.resume.loginTokens\": { \"token\": loginToken }\n    }\n  });\n};\n\n\n///\n/// CREATE USER HOOKS\n///\n\nvar onCreateUserHook = null;\nAccounts.onCreateUser = function (func) {\n  if (onCreateUserHook)\n    throw new Error(\"Can only call onCreateUser once\");\n  else\n    onCreateUserHook = func;\n};\n\n// XXX see comment on Accounts.createUser in passwords_server about adding a\n// second \"server options\" argument.\nvar defaultCreateUserHook = function (options, user) {\n  if (options.profile)\n    user.profile = options.profile;\n  return user;\n};\n\n// Called by accounts-password\nAccounts.insertUserDoc = function (options, user) {\n  // - clone user document, to protect from modification\n  // - add createdAt timestamp\n  // - prepare an _id, so that you can modify other collections (eg\n  // create a first task for every new user)\n  //\n  // XXX If the onCreateUser or validateNewUser hooks fail, we might\n  // end up having modified some other collection\n  // inappropriately. The solution is probably to have onCreateUser\n  // accept two callbacks - one that gets called before inserting\n  // the user document (in which you can modify its contents), and\n  // one that gets called after (in which you should change other\n  // collections)\n  user = _.extend({createdAt: +(new Date), _id: Random.id()}, user);\n\n  var result = {};\n  if (options.generateLoginToken) {\n    var stampedToken = Accounts._generateStampedLoginToken();\n    result.token = stampedToken.token;\n    Meteor._ensure(user, 'services', 'resume');\n    if (_.has(user.services.resume, 'loginTokens'))\n      user.services.resume.loginTokens.push(stampedToken);\n    else\n      user.services.resume.loginTokens = [stampedToken];\n  }\n\n  var fullUser;\n  if (onCreateUserHook) {\n    fullUser = onCreateUserHook(options, user);\n\n    // This is *not* part of the API. We need this because we can't isolate\n    // the global server environment between tests, meaning we can't test\n    // both having a create user hook set and not having one set.\n    if (fullUser === 'TEST DEFAULT HOOK')\n      fullUser = defaultCreateUserHook(options, user);\n  } else {\n    fullUser = defaultCreateUserHook(options, user);\n  }\n\n  _.each(validateNewUserHooks, function (hook) {\n    if (!hook(fullUser))\n      throw new Meteor.Error(403, \"User validation failed\");\n  });\n\n  try {\n    result.id = Meteor.users.insert(fullUser);\n  } catch (e) {\n    // XXX string parsing sucks, maybe\n    // https://jira.mongodb.org/browse/SERVER-3069 will get fixed one day\n    if (e.name !== 'MongoError') throw e;\n    var match = e.err.match(/^E11000 duplicate key error index: ([^ ]+)/);\n    if (!match) throw e;\n    if (match[1].indexOf('$emails.address') !== -1)\n      throw new Meteor.Error(403, \"Email already exists.\");\n    if (match[1].indexOf('username') !== -1)\n      throw new Meteor.Error(403, \"Username already exists.\");\n    // XXX better error reporting for services.facebook.id duplicate, etc\n    throw e;\n  }\n\n  return result;\n};\n\nvar validateNewUserHooks = [];\nAccounts.validateNewUser = function (func) {\n  validateNewUserHooks.push(func);\n};\n\n\n///\n/// MANAGING USER OBJECTS\n///\n\n// Updates or creates a user after we authenticate with a 3rd party.\n//\n// @param serviceName {String} Service name (eg, twitter).\n// @param serviceData {Object} Data to store in the user's record\n//        under services[serviceName]. Must include an \"id\" field\n//        which is a unique identifier for the user in the service.\n// @param options {Object, optional} Other options to pass to insertUserDoc\n//        (eg, profile)\n// @returns {Object} Object with token and id keys, like the result\n//        of the \"login\" method.\n//\nAccounts.updateOrCreateUserFromExternalService = function(\n  serviceName, serviceData, options) {\n  options = _.clone(options || {});\n\n  if (serviceName === \"password\" || serviceName === \"resume\")\n    throw new Error(\n      \"Can't use updateOrCreateUserFromExternalService with internal service \"\n        + serviceName);\n  if (!_.has(serviceData, 'id'))\n    throw new Error(\n      \"Service data for service \" + serviceName + \" must include id\");\n\n  // Look for a user with the appropriate service user id.\n  var selector = {};\n  var serviceIdKey = \"services.\" + serviceName + \".id\";\n\n  // XXX Temporary special case for Twitter. (Issue #629)\n  //   The serviceData.id will be a string representation of an integer.\n  //   We want it to match either a stored string or int representation.\n  //   This is to cater to earlier versions of Meteor storing twitter\n  //   user IDs in number form, and recent versions storing them as strings.\n  //   This can be removed once migration technology is in place, and twitter\n  //   users stored with integer IDs have been migrated to string IDs.\n  if (serviceName === \"twitter\" && !isNaN(serviceData.id)) {\n    selector[\"$or\"] = [{},{}];\n    selector[\"$or\"][0][serviceIdKey] = serviceData.id;\n    selector[\"$or\"][1][serviceIdKey] = parseInt(serviceData.id, 10);\n  } else {\n    selector[serviceIdKey] = serviceData.id;\n  }\n\n  var user = Meteor.users.findOne(selector);\n\n  if (user) {\n    // We *don't* process options (eg, profile) for update, but we do replace\n    // the serviceData (eg, so that we keep an unexpired access token and\n    // don't cache old email addresses in serviceData.email).\n    // XXX provide an onUpdateUser hook which would let apps update\n    //     the profile too\n    var stampedToken = Accounts._generateStampedLoginToken();\n    var setAttrs = {};\n    _.each(serviceData, function(value, key) {\n      setAttrs[\"services.\" + serviceName + \".\" + key] = value;\n    });\n\n    // XXX Maybe we should re-use the selector above and notice if the update\n    //     touches nothing?\n    Meteor.users.update(\n      user._id,\n      {$set: setAttrs,\n       $push: {'services.resume.loginTokens': stampedToken}});\n    return {token: stampedToken.token, id: user._id};\n  } else {\n    // Create a new user with the service data. Pass other options through to\n    // insertUserDoc.\n    user = {services: {}};\n    user.services[serviceName] = serviceData;\n    options.generateLoginToken = true;\n    return Accounts.insertUserDoc(options, user);\n  }\n};\n\n\n///\n/// PUBLISHING DATA\n///\n\n// Publish the current user's record to the client.\nMeteor.publish(null, function() {\n  if (this.userId) {\n    return Meteor.users.find(\n      {_id: this.userId},\n      {fields: {profile: 1, username: 1, emails: 1}});\n  } else {\n    return null;\n  }\n}, /*suppress autopublish warning*/{is_auto: true});\n\n// If autopublish is on, publish these user fields. Login service\n// packages (eg accounts-google) add to these by calling\n// Accounts.addAutopublishFields Notably, this isn't implemented with\n// multiple publishes since DDP only merges only across top-level\n// fields, not subfields (such as 'services.facebook.accessToken')\nvar autopublishFields = {\n  loggedInUser: ['profile', 'username', 'emails'],\n  otherUsers: ['profile', 'username']\n};\n\n// Add to the list of fields or subfields to be automatically\n// published if autopublish is on. Must be called from top-level\n// code (ie, before Meteor.startup hooks run).\n//\n// @param opts {Object} with:\n//   - forLoggedInUser {Array} Array of fields published to the logged-in user\n//   - forOtherUsers {Array} Array of fields published to users that aren't logged in\nAccounts.addAutopublishFields = function(opts) {\n  autopublishFields.loggedInUser.push.apply(\n    autopublishFields.loggedInUser, opts.forLoggedInUser);\n  autopublishFields.otherUsers.push.apply(\n    autopublishFields.otherUsers, opts.forOtherUsers);\n};\n\nif (Package.autopublish) {\n  // Use Meteor.startup to give other packages a chance to call\n  // addAutopublishFields.\n  Meteor.startup(function () {\n    // ['profile', 'username'] -> {profile: 1, username: 1}\n    var toFieldSelector = function(fields) {\n      return _.object(_.map(fields, function(field) {\n        return [field, 1];\n      }));\n    };\n\n    Meteor.server.publish(null, function () {\n      if (this.userId) {\n        return Meteor.users.find(\n          {_id: this.userId},\n          {fields: toFieldSelector(autopublishFields.loggedInUser)});\n      } else {\n        return null;\n      }\n    }, /*suppress autopublish warning*/{is_auto: true});\n\n    // XXX this publish is neither dedup-able nor is it optimized by our special\n    // treatment of queries on a specific _id. Therefore this will have O(n^2)\n    // run-time performance every time a user document is changed (eg someone\n    // logging in). If this is a problem, we can instead write a manual publish\n    // function which filters out fields based on 'this.userId'.\n    Meteor.server.publish(null, function () {\n      var selector;\n      if (this.userId)\n        selector = {_id: {$ne: this.userId}};\n      else\n        selector = {};\n\n      return Meteor.users.find(\n        selector,\n        {fields: toFieldSelector(autopublishFields.otherUsers)});\n    }, /*suppress autopublish warning*/{is_auto: true});\n  });\n}\n\n// Publish all login service configuration fields other than secret.\nMeteor.publish(\"meteor.loginServiceConfiguration\", function () {\n  return ServiceConfiguration.configurations.find({}, {fields: {secret: 0}});\n}, {is_auto: true}); // not techincally autopublish, but stops the warning.\n\n// Allow a one-time configuration for a login service. Modifications\n// to this collection are also allowed in insecure mode.\nMeteor.methods({\n  \"configureLoginService\": function (options) {\n    check(options, Match.ObjectIncluding({service: String}));\n    // Don't let random users configure a service we haven't added yet (so\n    // that when we do later add it, it's set up with their configuration\n    // instead of ours).\n    // XXX if service configuration is oauth-specific then this code should\n    //     be in accounts-oauth; if it's not then the registry should be\n    //     in this package\n    if (!(Accounts.oauth\n          && _.contains(Accounts.oauth.serviceNames(), options.service))) {\n      throw new Meteor.Error(403, \"Service unknown\");\n    }\n    if (ServiceConfiguration.configurations.findOne({service: options.service}))\n      throw new Meteor.Error(403, \"Service \" + options.service + \" already configured\");\n    ServiceConfiguration.configurations.insert(options);\n  }\n});\n\n\n///\n/// RESTRICTING WRITES TO USER OBJECTS\n///\n\nMeteor.users.allow({\n  // clients can modify the profile field of their own document, and\n  // nothing else.\n  update: function (userId, user, fields, modifier) {\n    // make sure it is our record\n    if (user._id !== userId)\n      return false;\n\n    // user can only modify the 'profile' field. sets to multiple\n    // sub-keys (eg profile.foo and profile.bar) are merged into entry\n    // in the fields list.\n    if (fields.length !== 1 || fields[0] !== 'profile')\n      return false;\n\n    return true;\n  },\n  fetch: ['_id'] // we only look at _id.\n});\n\n/// DEFAULT INDEXES ON USERS\nMeteor.users._ensureIndex('username', {unique: 1, sparse: 1});\nMeteor.users._ensureIndex('emails.address', {unique: 1, sparse: 1});\nMeteor.users._ensureIndex('services.resume.loginTokens.token',\n                          {unique: 1, sparse: 1});\n","// XXX These should probably not actually be public?\n\nAccounts.urls = {};\n\nAccounts.urls.resetPassword = function (token) {\n  return Meteor.absoluteUrl('#/reset-password/' + token);\n};\n\nAccounts.urls.verifyEmail = function (token) {\n  return Meteor.absoluteUrl('#/verify-email/' + token);\n};\n\nAccounts.urls.enrollAccount = function (token) {\n  return Meteor.absoluteUrl('#/enroll-account/' + token);\n};\n"]}