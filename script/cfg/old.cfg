function error() {
JOB="$0"              # job name
LASTLINE="$1"         # line of error occurrence
LASTERR="$2"          # error code
echo "ERROR in ${JOB} : line ${LASTLINE} with exit code ${LASTERR}"
#Backtrace1
exit 1
}


step3() {
  local i=0
  local FRAMES=${#BASH_LINENO[@]}
  # FRAMES-2 skips main, the last one in arrays
  for ((i=FRAMES-2; i>=0; i--)); do
    echo '  File' \"${BASH_SOURCE[i+1]}\", line ${BASH_LINENO[i]}, in ${FUNCNAME[i+1]}
    # Grab the source code of the line
    sed -n "${BASH_LINENO[i]}{s/^/    /;p}" "${BASH_SOURCE[i+1]}"
  done
}

function step2 () {
#local file=/tmp/error.txt

   STACK=""
   # to avoid noise we start with 1 to skip get_stack caller
   local i
   local stack_size=${#FUNCNAME[1]}
   for (( i=1; i<$stack_size ; i++ )); do
      local func="${FUNCNAME[$i]}"
      [ x$func = x ] && func=MAIN
      local linen="${BASH_LINENO[(( i - 1 ))]}"
      local src="${BASH_SOURCE[$i]}"
      [ x"$src" = x ] && src=non_file_source

      STACK+=$'\n'"   "$func" "$src" "$linen
   done

   
  
  #echo "$STACK" > $file
  
  #gxmessage -file "$file" $GXMESSAGET

  #zenity1 "$file" 
}

error_handler(){
die
}
error_handler1(){
die
}
function Backtrace1 
{
#flite 'back - trace'
    local _start_from_=0

    local params=( "$@" )
    if (( "${#params[@]}" >= "1" ))
    then
        _start_from_="$1"
    fi

    local i=0
    local first=false
    while caller $i > /dev/null
    do
        if test -n "$_start_from_" && (( "$i" + 1   >= "$_start_from_" ))
        then
            if test "$first" == false
            then
                trace "BACKTRACE IS:"
                first=true
            fi
            caller $i
        fi
        let "i=i+1"
    done
    if [ $PAUSE = true ];then
 flite 'sleep 10 seconds'
    sleep1 10
    else

 trace "don't sleep 10 seconds"
    fi
   
    trace '_+_+_+_+_+'
}


