#notify_send1 'how to catch errors?'
#http://www.commandlinefu.com/commands/matching/errors/ZXJyb3Jz/sort-by-votes

#die(){
##notify_send1 'die' 
#red 'error!'
##sleep1 5
#    #echo -n '' > $file_error
#
#    #flite 'die'
#    #notify_send3 'trap error'
#    #gxmessage -file $file_error $GXMESSAGET
#    #sleep1 5
#    #breakpoint 3
#    #zenity1 $file_error '' ''
#    #sleep1 10
#    #remove_locker $file_locker
#    #exit 1
#   eval breakpoint 
#}
show_err(){

    somecommand 2>&1 >> logfile | tee -a logfile
}

breakpoint(){
    notify_send1 error.cfg "$?"
    #optional : use of var: msg
    #notify_send1 'breakpoint' 
    local msg="$1"
    #flite "error - $msg" &
    echo -n '' > $file_error

    for ((i = 1; i < ${#FUNCNAME[@]}; i++)); do
local str1="${BASH_SOURCE[$i]}"
local str2="${BASH_LINENO[$i-1]}"
local str3="${FUNCNAME[$i]}"

#local str4=`sed -n "${BASH_LINENO[$i-1]}p" $0 `
        echo  "$str1:$str2:$str3" >> $file_error
        if [ "$str1" = '' ];then
            local filename=`grep  "$str3()" $CFG_DIR/*.cfg -l`
            if [ "$filename" ];then
            notify_send4 "breakpoint $filename" "gedit $filename"
            fi
        else
            notify_send4 "breakpoint $str1:$str2:$str3" "gedit $str1"
        fi



    done
    #local num=${1:-$const_coller}
    #trace "const caller =  $num"
    #local secret=$(secret $num)
    #echo  "caller::: for num:$num: secret:$secret" >> $file_error

    local  cmd="gxmessage -file $file_error $GXMESSAGET -title 'breakpoint: $msg'"

    #local line="show error?"
    #notify_send4 "$line" "$cmd"
    eval "$cmd"
    exiting 
}

secret(){
    local num=${1:-2}
    local caller="${FUNCNAME[$num]}"
    local lineno="${BASH_LINENO[$num-1]}"
    local filename="${BASH_SOURCE[$num]}"
    #$0:$filename:
    local callers="$caller(): $lineno: $0 : $filename"
    #gxmessage $GXMESSAGET "$callers" -title 'callers' 'recent points'
    #trace "secret callers:: $callers"
    echo "$callers"
}
die(){
    breakpoint
}
export -f breakpoint 

export -f secret 

#export -f die 
trap 'eval breakpoint' SIGINT SIGTERM
trap 'eval breakpoint' ERR 

