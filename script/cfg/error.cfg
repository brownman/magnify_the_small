#notify-send1 'how to catch errors?'
#http://www.commandlinefu.com/commands/matching/errors/ZXJyb3Jz/sort-by-votes

die(){
#notify-send1 'die' 
red 'error!'
sleep1 5
    #echo -n '' > $file_error

    #flite 'die'
    #notify-send3 'trap error'
    #gxmessage -file $file_error $GXMESSAGET
    #sleep1 5
    breakpoint 3
    #zenity1 $file_error '' ''
    #sleep1 10
    #remove_locker $file_locker
    #exit 1
}
breakpoint(){
    #notify-send1 'breakpoint' 'print and continue'
    local num=${1:-"$const_coller"}
    trace "const caller =  $num"
    local secret=$(secret $num)
    #secret 3
    #show_caller
    echo -n '' > $file_error
    #flite 'step 1'

    # skipping i=0 as this is print_call_trace itself
    for ((i = 1; i < ${#FUNCNAME[@]}; i++)); do
        echo  "${BASH_SOURCE[$i]}:${BASH_LINENO[$i-1]}:${FUNCNAME[$i]} " >> $file_error
        sed -n "${BASH_LINENO[$i-1]}p" $0 
    done
 
echo -e "\ncaller: $num: $secret" >> $file_error

    #cat -n $file_error
   local  cmd="gxmessage -file $file_error $GXMESSAGET -title 'die'"

local line="show error? $secret"
local line_escaped=$( escape_dq "$line" )


 #cat -n $file_error
 notify-send4 "$line_escaped" "$cmd"
}
        
secret(){
    local num="$1"
    local caller="${FUNCNAME[$num]}"
    local lineno="${BASH_LINENO[$num-1]}"
    local filename="${BASH_SOURCE[$num]}"
    #$0:$filename:
    local callers="$caller():\n $lineno: $0 :\n $filename"
    #gxmessage $GXMESSAGET "$callers" -title 'callers' 'recent points'
   #trace "secret callers:: $callers"
    echo "$callers"
}
export -f breakpoint 

export -f secret 

export -f die 
trap exiting SIGINT SIGTERM
trap die ERR 
