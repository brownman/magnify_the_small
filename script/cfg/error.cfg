#notify_send1 'how to catch errors?'
#http://www.commandlinefu.com/commands/matching/errors/ZXJyb3Jz/sort-by-votes

#die(){
##notify_send1 'die' 
#red 'error!'
##sleep1 5
#    #echo -n '' > $file_error
#
#    #flite 'die'
#    #notify_send3 'trap error'
#    #gxmessage -file $file_error $GXMESSAGET
#    #sleep1 5
#    #breakpoint 3
#    #zenity1 $file_error '' ''
#    #sleep1 10
#    #remove_locker $file_locker
#    #exit 1
#   eval breakpoint 
#}
show_err(){

    somecommand 2>&1 >> logfile | tee -a logfile
}

breakpoint(){
    #optional : use of var: msg
 #notify_send1 'breakpoint' 
local msg="$1"
#flite "error - $msg" &
    echo -n '' > $file_error

    for ((i = 1; i < ${#FUNCNAME[@]}; i++)); do
        echo  "${BASH_SOURCE[$i]}:${BASH_LINENO[$i-1]}:${FUNCNAME[$i]} " >> $file_error
        sed -n "${BASH_LINENO[$i-1]}p" $0 
    done
  #local num=${1:-$const_coller}
    #trace "const caller =  $num"
    #local secret=$(secret $num)
    #echo  "caller::: for num:$num: secret:$secret" >> $file_error

    local  cmd="gxmessage -file $file_error $GXMESSAGET -title 'breakpoint: $msg'"

    #local line="show error?"
    #notify_send4 "$line" "$cmd"
    eval "$cmd"
   exit 
}

secret(){
    local num=${1:-2}
    local caller="${FUNCNAME[$num]}"
    local lineno="${BASH_LINENO[$num-1]}"
    local filename="${BASH_SOURCE[$num]}"
    #$0:$filename:
    local callers="$caller(): $lineno: $0 : $filename"
    #gxmessage $GXMESSAGET "$callers" -title 'callers' 'recent points'
    #trace "secret callers:: $callers"
    echo "$callers"
}
export -f breakpoint 

export -f secret 

#export -f die 
trap 'eval breakpoint' SIGINT SIGTERM
trap 'eval breakpoint' ERR 

