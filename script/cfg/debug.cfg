# Log Call Stack
#http://www.fvue.nl/wiki/Bash:_Error_handling
#http://www.linuxcommand.org/lc3_lts0080.php
#http://wiki.bash-hackers.org/commands/builtin/caller
#http://www.skybert.net/unix/bash/serious-programming-in-bash/
show_vars(){
trace 'show vars'
trace "DEBUG: $DEBUG"
trace "VERBOSE: $VERBOSE"
}
debug(){
if [ "$VERBOSE" = true ];then
trace "$1 :  $2"
fi

}


exiting()
{
    trace "exiting() got: 0:$0 1: $1 , 2: $2"
    notify-send 'exiting'
 exit 1 
    #notify-send 'Exiting'
    #if [ "$VERBOSE" = true ];then
        #Backtrace1
        #trace 'backtrace'
    #fi
    
    #flite exiting
#trace 'exiting'
#die
}


to_continue(){

            $( messageYN1 "test failed ?" "y/n" )
               #tracex 'is 1?' "$result"
            result=$?
            if [[ $result -eq 0 ]];then
            
                exiting
            else
notify-send 'continue'
            fi



}


tracex(){


#    local btn_str="${3:-ok}"
    local title="tracex"
    local msg="$0: $1 : $2"

    gxmessage $GXMESSAGET "$msg" -title "$title" 
    to_continue  
   
    #-buttons "$btn_str":0 $ICONIC

    #flite "$1"
}
die(){


echo -n '' > $file_error

flite 'die'
step1 'oops'
  gxmessage -file $file_error $GXMESSAGET
  #zenity1 $file_error '' ''
sleep1 10
remove_locker $file_locker
  exit 1
}
breakpoint(){

echo -n '' > $file_error

flite 'breakpoint'
step1 'oops'
  gxmessage -file $file_error $GXMESSAGET
  #zenity1 $file_error '' ''
}
#error_handler2(){
#trace 'problem'
#}
#error_handler3(){
#flite 'error handler'
#    local msg='found error'
#    trace "$msg"
#    Backtrace1
#    exit 1
#}
#

function step1()
{
#flite 'step 1'

    # skipping i=0 as this is print_call_trace itself
    for ((i = 1; i < ${#FUNCNAME[@]}; i++)); do
        echo  ${BASH_SOURCE[$i]}:${BASH_LINENO[$i-1]}:${FUNCNAME[$i]}"(): " >> $file_error
        sed -n "${BASH_LINENO[$i-1]}p" $0 
    done

}
#error_handler(){
#die
#}
#
#
is_valid(){
    debug   "is_valid() got:"
    debug   "1:$1 2:$2"

    if [ "$1" = '' ];then
        notify-send 'no arg given'
        #error_handler
        #return
        die
    fi

    local file=$1
    local result=0
    debug  'check existance'

    local res=$(ls $file 1>/dev/null 2>&1 && echo 'y' || echo 'n')
    if [ "$res" = 'y' ];then
        debug  'file exist'
        if  [ -s $file ];then
            debug  'file has content'
            actualsize=$(du -b "$file" | cut -f 1)
            debug 'size: '
            debug  $actualsize

            if [ $actualsize -eq 0 ];then
                debug   'file is corrupted'
                #let "result = 1"
            else
                debug  'file seems ok'
                let "result = 1"
            fi
        else
            debug  'file is empty'
        fi
    else
        debug  'file not exist'
    fi
    return $result
}
trace(){


        echo "_: $1 : $2 :$3" >&2
}
run_silently(){
local cmd1="$1"
eval "$cmd1" &> /dev/null &
}


export -f run_silently 
export -f trace
export -f is_valid 
export -f breakpoint 
export -f die 
#export -f error_handler
export -f step1 
#export -f error_handler1

#
#trace "DEBUG: $DEBUG"
#trace "VERBOSE: $VERBOSE"
#trap 'error ${LINENO} ${$?}' ERR
trap die ERR SIGINT SIGTERM
                                       # ! ! ! TRAP ERR ! ! !
#trap "die ${LINENO} ${$?}" SIGINT SIGTERM

export -f tracex
export -f exiting
export -f to_continue 


export -f debug
export -f show_vars 
