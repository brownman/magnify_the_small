# Log Call Stack
#http://www.fvue.nl/wiki/Bash:_Error_handling
#http://www.linuxcommand.org/lc3_lts0080.php
#http://wiki.bash-hackers.org/commands/builtin/caller
#http://www.skybert.net/unix/bash/serious-programming-in-bash/

command_not_found_handler(){
notify-send "You tried to run $1 with arg $2"
}
notify-send(){
breakpoint false
/usr/bin/notify-send "$1"

}
mantion(){

   local str="$1" 
   local num=${2:-9}
        ############# 
        random1 $num
        local res=$?
        if [ $res -eq 0 ];then
            notify-send  "mantion:" "$num: $str"
            breakpoint false
        else
              trace    "$str"
        fi
        #############
}
mantion_cmd(){
flite 'keep on pushing productivity forward'
   local cmd="$1" 
   local num=${2:-5}
        ############# 
        random1 $num
        local res=$?
        if [ $res -eq 0 ];then
            notify-send  "mantion cmd:" "$num: $cmd"
            breakpoint false
            eval "$cmd"
        else
              trace    "$str"
        fi

        #############
}

mantion_file(){

   local file="$1" 
   local num=${2:-9}
is_valid   $file
    res0=$?
    if [ $res0 -eq 0 ];then
        gxmessage -title "invalid file:" "$file" $GXMESSAGET
    else
      ############# 
        random1 $num
        local res=$?
        if [ $res -eq 0 ];then
        notify-send "minimize file"
          (  gxmessage $GXMESSAGET -file "$file"  &)
        else
            #notify-send  "mantion:" "$num: $str"

           ( cat    "$file" &)

        fi
        #############
    fi
  
}


got(){
local str="$@"
   notify-send  "got:" "$str" 
}
assert_equal_str(){
flite 'expect string'

local from="$1"
local to="${2:-'???'}"


local res=$(echo "$from" | grep -o "$to")
if [ "$res" = '' ];then

gxmessage $GXMESSAGET $GXMESSAGE1 "res: $res <> $from  ?==? $to" -title "expect str: $to" 
exiting
else
notify-send 'continue'
fi

}
assert_equal_cmd(){
COMMANDER=true

local from="$1"
local to=${2:-'???'}

flite 'expect command'
local tmp=$(commander "$from")


local res=$(echo "$tmp" | grep -o "$to")


if [ "$res" = '' ];then

gxmessage $GXMESSAGET $GXMESSAGE1 "$to  ?==? $tmp" -title "expect cmd: $to" 
exiting
else
notify-send 'continue'
fi
}


show_vars(){
trace 'show vars'
trace "DEBUG: $DEBUG"
trace "VERBOSE: $VERBOSE"
}
debug(){
if [ "$VERBOSE" = true ];then
trace "$1 :  $2"
fi

}


exiting()
{
    trace "exiting() got: 0:$0 1: $1 , 2: $2"
    notify-send "Exiting" "$file_locker" 
    breakpoint false
    #"caller: ${FUNCNAME[2]}"
 exit 1 
    #notify-send 'Exiting'
    #if [ "$VERBOSE" = true ];then
        #Backtrace1
        #trace 'backtrace'
    #fi
    
    #flite exiting
#trace 'exiting'
#die
}


to_continue(){

            $( messageYN1 "test failed ?" "y/n" )
               #tracex 'is 1?' "$result"
            result=$?
            if [[ $result -eq 0 ]];then
            
                exiting
            else
notify-send 'continue'
            fi



}


tracex(){


#    local btn_str="${3:-ok}"
    local title="tracex"
    local msg="$0: $1 : $2"

    gxmessage $GXMESSAGET "$msg" -title "$title" 
    to_continue  
   
    #-buttons "$btn_str":0 $ICONIC

    #flite "$1"
}
die(){


echo -n '' > $file_error

flite 'die'
step1 'oops'
  gxmessage -file $file_error $GXMESSAGET
  #zenity1 $file_error '' ''
sleep1 10
remove_locker $file_locker
  exit 1
}
#show_caller(){
#
#    #gxmessage $GXMESSAGET "caller: ${FUNCNAME[2]} ${FUNCNAME[3]}  ${FUNCNAME[4]}"
#
#  }

breakpoint(){
#show_caller
echo -n '' > $file_error

#flite 'breakpoint'
step1 'oops'
local gui=${1:-'true'}
if [ "$gui" = true ];then
  gxmessage -file $file_error $GXMESSAGET -title "$0"
else
  cat  $file_error &
fi

  #zenity1 $file_error '' ''
}
#error_handler2(){
#trace 'problem'
#}
#error_handler3(){
#flite 'error handler'
#    local msg='found error'
#    trace "$msg"
#    Backtrace1
#    exit 1
#}
#

function step1()
{
#flite 'step 1'

    # skipping i=0 as this is print_call_trace itself
    for ((i = 1; i < ${#FUNCNAME[@]}; i++)); do
        echo  ${BASH_SOURCE[$i]}:${BASH_LINENO[$i-1]}:${FUNCNAME[$i]}"(): " >> $file_error
        sed -n "${BASH_LINENO[$i-1]}p" $0 
    done

}
#error_handler(){
#die
#}
#
#
is_valid(){
    debug   "is_valid() got:"
    debug   "1:$1 2:$2"

    if [ "$1" = '' ];then
        notify-send 'no arg given'
        #error_handler
        #return
        die
    fi

    local file=$1
    local result=0
    debug  'check existance'

    local res=$(ls $file 1>/dev/null 2>&1 && echo 'y' || echo 'n')
    if [ "$res" = 'y' ];then
        debug  'file exist'
        if  [ -s $file ];then
            debug  'file has content'
            actualsize=$(du -b "$file" | cut -f 1)
            debug 'size: '
            debug  $actualsize

            if [ $actualsize -eq 0 ];then
                debug   'file is corrupted'
                #let "result = 1"
            else
                debug  'file seems ok'
                let "result = 1"
            fi
        else
            debug  'file is empty'
        fi
    else
        debug  'file not exist'
    fi
    return $result
}
trace(){


        echo "_: $1 : $2 :$3" >&2
}
tracen(){

        echo  -n "${1}${2}" >&2
}
run_silently(){
local cmd1="$1"
eval "$cmd1" &> /dev/null &
}


#export -f trace 
export -f run_silently 

export -f is_valid 
export -f breakpoint 
export -f die 
#export -f error_handler
export -f step1 
#export -f error_handler1

#
#trace "DEBUG: $DEBUG"
#trace "VERBOSE: $VERBOSE"
#trap 'error ${LINENO} ${$?}' ERR
trap die ERR 
#trap SIGINT SIGTERM
                                       # ! ! ! TRAP ERR ! ! !
trap "eval exiting ${LINENO} ${$?}" SIGINT SIGTERM

export -f trace


export -f tracen 
export -f tracex
export -f exiting
export -f to_continue 


export -f debug
export -f show_vars 

export -f assert_equal_str

export -f assert_equal_cmd

export -f got

export -f mantion 
export -f mantion_file 
export -f command_not_found_handler

#export -f show_caller
export -f mantion_cmd
