# Log Call Stack

#http://wiki.bash-hackers.org/commands/builtin/caller
#http://www.skybert.net/unix/bash/serious-programming-in-bash/
exiting()
{
    trace "exiting() got: 0:$0 1: $1 , 2: $2"
  
    #notify-send 'Exiting'
    #if [ "$VERBOSE" = true ];then
        #Backtrace1
        #trace 'backtrace'
    #fi
    
    #flite exiting
#trace 'exiting'
die
}


to_continue(){

            $( messageYN1 "test failed ?" "y/n" )
               #tracex 'is 1?' "$result"
            result=$?
            if [[ $result -eq 0 ]];then
            
                exiting
            else
notify-send 'continue'
            fi



}


tracex(){


#    local btn_str="${3:-ok}"
    local title="$0"
    local msg="$1 : $2"

    gxmessage $GXMESSAGET "$msg" -title "$title" 
    to_continue  
   
    #-buttons "$btn_str":0 $ICONIC

    #flite "$1"
}
die(){


echo -n '' > $file_error

flite 'die'
step1 'oops'
  #gxmessage -file $file_error $GXMESSAGET
  #zenity1 $file_error '' ''
sleep1 10
remove_locker $file_locker
  exit 1
}
breakpoint(){

echo -n '' > $file_error

flite 'breakpoint'
step1 'oops'
  gxmessage -file $file_error $GXMESSAGET
  #zenity1 $file_error '' ''
}
error_handler2(){
trace 'problem'
}
error_handler3(){
flite 'error handler'
    local msg='found error'
    trace "$msg"
    Backtrace1
    exit 1
}


function step1()
{
#flite 'step 1'

    # skipping i=0 as this is print_call_trace itself
    for ((i = 1; i < ${#FUNCNAME[@]}; i++)); do
        echo  ${BASH_SOURCE[$i]}:${BASH_LINENO[$i-1]}:${FUNCNAME[$i]}"(): " >> $file_error
        sed -n "${BASH_LINENO[$i-1]}p" $0 
    done

}
error_handler(){
die
}



export -f breakpoint 
export -f die 
export -f error_handler
export -f step1 
#export -f error_handler1

#
#trace "DEBUG: $DEBUG"
#trace "VERBOSE: $VERBOSE"
#trap 'error ${LINENO} ${$?}' ERR
trap die ERR                                                           # ! ! ! TRAP ERR ! ! !
trap "eval exiting ${LINENO} ${$?}" SIGINT SIGTERM

export -f tracex
export -f exiting
export -f to_continue 
