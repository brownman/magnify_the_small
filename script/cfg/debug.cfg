# Log Call Stack
#http://www.fvue.nl/wiki/Bash:_Error_handling
#http://www.linuxcommand.org/lc3_lts0080.php
#http://wiki.bash-hackers.org/commands/builtin/caller
#http://www.skybert.net/unix/bash/serious-programming-in-bash/
# about file:
# test the first test listen on blank.yaml:testing
#http://www.thegeekstuff.com/2010/10/expect-examples/#more-6218
#args=$(tasker fetch "$args0")
#http://tldp.org/LDP/abs/html/comparison-ops.html
#http://stackoverflow.com/questions/3265803/bash-string-equality
#cry
secret(){
    local num="$1"
    local caller="${FUNCNAME[$num]}"
    local lineno="${BASH_LINENO[$num-1]}"
    local filename="${BASH_SOURCE[$num]}"
    #$0:$filename:
    local callers="$caller():$lineno: $0 : $filename"
    #gxmessage $GXMESSAGET "$callers" -title 'callers' 'recent points'
   trace "secret callers:: $callers"
    echo "$callers"
}
update_commander(){
    local str=$(secret 2)
    notify-send1 "update commander" "$str"

    COMMANDER1=true
    local cmd='flite "just remind about commander update ";breakpoint'
    every "$cmd" 5
    #assert_equal_str "$COMMANDER"
}
remove_commander(){

    local str=$(secret 2)
    notify-send1 "update commander" "$str"

    COMMANDER1=false
    #assert_equal_str "$COMMANDER"
}
#command_not_found_handler(){
#    notify-send "You tried to run $1 with arg $2"
#}

#got(){
#    local str="$@"
#    notify-send  "got:" "$str" 
#}
debug(){
    if [ "$VERBOSE" = true ];then
        #notify-send1
        trace "$@"
    else
        tracen '$'
    fi

    #eval "$cmd1" &> /dev/null &

}


exiting()
{
    trace "exiting() got: 0:$0 1: $1 , 2: $2"
    notify-send1 "Exiting" "$file_locker" 
    #breakpoint false
    #"caller: ${FUNCNAME[2]}"

    #notify-send 'Exiting'
    #if [ "$VERBOSE" = true ];then
    #Backtrace1
    #trace 'backtrace'
    #fi

    flite 'exiting'
    #trace 'exiting'
    #die
    #cmd="rm $file_locker"
    #COMMANDER=true
    #commander "$cmd"
    exit 1 
}


#to_continue(){
#
#    $( messageYN1 "test failed ?" "y/n" )
#    #tracex 'is 1?' "$result"
#    result=$?
#    if [[ $result -eq 0 ]];then
#
#        exiting
#    else
#        notify-send 'continue'
#    fi
#
#
#
#}
#


die(){


    #echo -n '' > $file_error

    flite 'die'
    notify-send3 'die'
    #gxmessage -file $file_error $GXMESSAGET
    #breakpoint
    #zenity1 $file_error '' ''
    #sleep1 10
    #remove_locker $file_locker
    exit 1
}
#show_caller(){
#
#    #gxmessage $GXMESSAGET "caller: ${FUNCNAME[2]} ${FUNCNAME[3]}  ${FUNCNAME[4]}"
#
#  }

breakpoint(){
    local num=${1:-2}
    local secret=$(secret $num)
    #secret 3
    #show_caller
    echo -n '' > $file_error
    #flite 'step 1'

    # skipping i=0 as this is print_call_trace itself
    for ((i = 1; i < ${#FUNCNAME[@]}; i++)); do
        echo  "${BASH_SOURCE[$i]}:${BASH_LINENO[$i-1]}:${FUNCNAME[$i]} " >> $file_error
        sed -n "${BASH_LINENO[$i-1]}p" $0 
    done

    gxmessage -file $file_error $GXMESSAGET -title "$secret"
    exiting
}
#error_handler2(){
#trace 'problem'
#}
#error_handler3(){
#flite 'error handler'
#    local msg='found error'
#    trace "$msg"
#    Backtrace1
#    exit 1
#}
#



#local cmd="clean_file $file_logger"
#every "$cmd" 150
    #update_file $file_logger "_: $1 : $2 :$3" 
     #>> $file_logger
    #&1> /dev/null
#error_handler(){
#die
#}
#
#
#local cmd="clean_file $file_logger"
#every "$cmd"  150
    #update_file $file_logger "_${1}${2}" 
     #>> $file_logger
    #&1> /dev/null
trace(){

echo "$1|$2" > /dev/null
}
tracen(){

echo "$1|$2" > /dev/null

}
run_silently(){
    local cmd1="$1"
    eval "$cmd1" &> /dev/null &
}

        
export -f trace
export -f tracen 
export -f exiting
#export -f to_continue 
export -f debug
#export -f got
#export -f command_not_found_handler
export -f run_silently 
export -f breakpoint 
export -f secret 
export -f die 

export -f remove_commander 
export -f update_commander 

#trap 'error ${LINENO} ${$?}' ERR
#trap SIGINT SIGTERM
# ! ! ! TRAP ERR ! ! !

#trap "eval exiting ${LINENO} ${$?}" SIGINT SIGTERM
#http://en.wikipedia.org/wiki/Unix_signal
trap exiting SIGINT SIGTERM
trap die ERR 
