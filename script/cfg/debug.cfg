# Log Call Stack
#http://www.fvue.nl/wiki/Bash:_Error_handling
#http://www.linuxcommand.org/lc3_lts0080.php
#http://wiki.bash-hackers.org/commands/builtin/caller
#http://www.skybert.net/unix/bash/serious-programming-in-bash/
assert_equal_file(){
    flite 'expect file'
    local file="$1"
    local from=$(echo "-$(cat $file)-")
    local to="${2:-'???'}"


    local res=$(echo "$from" | grep -o "$to")
    if [ "$res" = '' ];then

        gxmessage $GXMESSAGET $GXMESSAGE1 "_$res|$from|$to_" -title "expect file: $to" 
        breakpoint 
    else
        notify-send 'continue'
    fi

}
assert_equal_str(){
    flite 'expect string'

    local from="$1"
    local to="${2:-'???'}"


    local res=$(echo "$from" | grep -o "$to")
    if [ "$res" = '' ];then

        gxmessage $GXMESSAGET $GXMESSAGE1 "res: $res <> $from  ?==? $to" -title "expect str: $to" 

        breakpoint

    else
        notify-send 'continue'
    fi


}
assert_equal_cmd(){
    COMMANDER=true

    local from="$1"
    local to=${2:-'???'}

    flite 'expect command'
    local tmp=$(commander "$from")


    local res=$(echo "$tmp" | grep -o "$to")


    if [ "$res" = '' ];then

        gxmessage $GXMESSAGET $GXMESSAGE1 "$to  ?==? $tmp" -title "expect cmd: $to" 
        breakpoint
    else
        notify-send 'continue'
    fi
}


command_not_found_handler(){
    notify-send "You tried to run $1 with arg $2"
}
mantion(){

    local str="$1" 
    local num=${2:-9}
    ############# 
    random1 $num
    local res=$?
    if [ $res -eq 0 ];then
        notify-send  "mantion:" "$num: $str"
    else
        trace    "$str"
    fi
    #############
}
mantion_cmd(){
    local cmd="$1" 
    local num=${2:-5}
    ############# 
    random1 $num
    local res=$?
    if [ $res -eq 0 ];then
        notify-send  "mantion cmd:" "$num: $cmd"
        eval "$cmd"
    else
        trace    "$str"

    fi

    #############
}

mantion_file(){

    local file="$1" 
    local num=${2:-9}
    is_valid   $file
    res0=$?
    if [ $res0 -eq 0 ];then
        gxmessage -title "invalid file:" "$file" $GXMESSAGET
    else
        ############# 
        random1 $num
        local res=$?
        if [ $res -eq 0 ];then
            notify-send "minimize file"
            (  gxmessage $GXMESSAGET -file "$file"  &)
        else
            #notify-send  "mantion:" "$num: $str"

            ( cat    "$file" &)

        fi
        #############
    fi

}


got(){
    local str="$@"
    notify-send  "got:" "$str" 
}
debug(){
    #if [ "$VERBOSE" = true ];then
    #notify-send1
    trace "$@"
    #fi

}


exiting()
{
    trace "exiting() got: 0:$0 1: $1 , 2: $2"
    notify-send "Exiting" "$file_locker" 
    #breakpoint false
    #"caller: ${FUNCNAME[2]}"
    exit 1 
    #notify-send 'Exiting'
    #if [ "$VERBOSE" = true ];then
    #Backtrace1
    #trace 'backtrace'
    #fi

    flite exiting
    #trace 'exiting'
    #die
}


to_continue(){

    $( messageYN1 "test failed ?" "y/n" )
    #tracex 'is 1?' "$result"
    result=$?
    if [[ $result -eq 0 ]];then

        exiting
    else
        notify-send 'continue'
    fi



}


tracex(){


    #    local btn_str="${3:-ok}"
    local title="tracex"
    local msg="$0: $1 : $2"

    gxmessage $GXMESSAGET "$msg" -title "$title" 
    to_continue  

    #-buttons "$btn_str":0 $ICONIC

    #flite "$1"
}
die(){


    echo -n '' > $file_error

    flite 'die'
    #gxmessage -file $file_error $GXMESSAGET
    breakpoint
    #zenity1 $file_error '' ''
    sleep1 10
    #remove_locker $file_locker
    exit 1
}
#show_caller(){
#
#    #gxmessage $GXMESSAGET "caller: ${FUNCNAME[2]} ${FUNCNAME[3]}  ${FUNCNAME[4]}"
#
#  }

breakpoint(){
    #show_caller
    echo -n '' > $file_error
   #flite 'step 1'

    # skipping i=0 as this is print_call_trace itself
    for ((i = 1; i < ${#FUNCNAME[@]}; i++)); do
        echo  "${BASH_SOURCE[$i]}:${BASH_LINENO[$i-1]}:${FUNCNAME[$i]} " >> $file_error
        sed -n "${BASH_LINENO[$i-1]}p" $0 
    done

    gxmessage -file $file_error $GXMESSAGET -title "$0"
    exiting
}
#error_handler2(){
#trace 'problem'
#}
#error_handler3(){
#flite 'error handler'
#    local msg='found error'
#    trace "$msg"
#    Backtrace1
#    exit 1
#}
#


#error_handler(){
#die
#}
#
#
trace(){


    echo "_: $1 : $2 :$3" >&2
}
tracen(){

    echo  -n "${1}${2}" >&2
}
run_silently(){
    local cmd1="$1"
    eval "$cmd1" &> /dev/null &
}



export -f trace
export -f tracen 
export -f tracex
export -f exiting
export -f to_continue 
export -f debug
export -f got
export -f mantion 
export -f mantion_file 
export -f command_not_found_handler
export -f mantion_cmd
export -f run_silently 

export -f breakpoint 
export -f die 

export -f assert_equal_str
export -f assert_equal_cmd
export -f assert_equal_file

#trap 'error ${LINENO} ${$?}' ERR
#trap SIGINT SIGTERM
# ! ! ! TRAP ERR ! ! !
trap "eval exiting ${LINENO} ${$?}" SIGINT SIGTERM
trap die ERR 
