# Log Call Stack
#http://www.fvue.nl/wiki/Bash:_Error_handling
#http://www.linuxcommand.org/lc3_lts0080.php
#http://wiki.bash-hackers.org/commands/builtin/caller
#http://www.skybert.net/unix/bash/serious-programming-in-bash/
assert_equal_file(){
    flite 'expect file'
    local file="$1"
    local from=$(echo "-$(cat $file)-")
    local to="${2:-'???'}"


    local res=$(echo "$from" | grep -o "$to")
    if [ "$res" = '' ];then

        gxmessage $GXMESSAGET $GXMESSAGE1 "_$res|$from|$to_" -title "expect file: $to" 
        breakpoint 
    else
        notify-send 'continue'
    fi

}

assert_equal_str(){
    flite 'expect string'

    local from="$1"
    local to="${2:-'???'}"


    local res=$(echo "$from" | grep -o "$to")
    if [ "$res" = '' ];then

        gxmessage $GXMESSAGET $GXMESSAGE1 "res: $res <> $from  ?==? $to" -title "expect str: $to" 

        breakpoint

    else
        notify-send 'continue'
    fi


}
assert_equal_cmd(){
    COMMANDER=true

    local from="$1"
    local to=${2:-'???'}

    flite 'expect command'
    local tmp=$(commander "$from")


    local res=$(echo "$tmp" | grep -o "$to")


    if [ "$res" = '' ];then

        gxmessage $GXMESSAGET $GXMESSAGE1 "$to  ?==? $tmp" -title "expect cmd: $to" 
        breakpoint
    else
        notify-send 'continue'
    fi
}


command_not_found_handler(){
    notify-send "You tried to run $1 with arg $2"
}

got(){
    local str="$@"
    notify-send  "got:" "$str" 
}
debug(){
    #if [ "$VERBOSE" = true ];then
    #notify-send1
    trace "$@"
    #fi

}


exiting()
{
    trace "exiting() got: 0:$0 1: $1 , 2: $2"
    notify-send1 "Exiting" "$file_locker" 
    #breakpoint false
    #"caller: ${FUNCNAME[2]}"

    #notify-send 'Exiting'
    #if [ "$VERBOSE" = true ];then
    #Backtrace1
    #trace 'backtrace'
    #fi

    flite 'exiting'
    #trace 'exiting'
    #die

    exit 1 
}


to_continue(){

    $( messageYN1 "test failed ?" "y/n" )
    #tracex 'is 1?' "$result"
    result=$?
    if [[ $result -eq 0 ]];then

        exiting
    else
        notify-send 'continue'
    fi



}


tracex(){


    #    local btn_str="${3:-ok}"
    local title="tracex"
    local msg="$0: $1 : $2"

    gxmessage $GXMESSAGET "$msg" -title "$title" 
    to_continue  

    #-buttons "$btn_str":0 $ICONIC

    #flite "$1"
}
die(){


    echo -n '' > $file_error

    flite 'die'
    #gxmessage -file $file_error $GXMESSAGET
    breakpoint
    #zenity1 $file_error '' ''
    sleep1 10
    #remove_locker $file_locker
    exit 1
}
#show_caller(){
#
#    #gxmessage $GXMESSAGET "caller: ${FUNCNAME[2]} ${FUNCNAME[3]}  ${FUNCNAME[4]}"
#
#  }

breakpoint(){
    #show_caller
    echo -n '' > $file_error
   #flite 'step 1'

    # skipping i=0 as this is print_call_trace itself
    for ((i = 1; i < ${#FUNCNAME[@]}; i++)); do
        echo  "${BASH_SOURCE[$i]}:${BASH_LINENO[$i-1]}:${FUNCNAME[$i]} " >> $file_error
        sed -n "${BASH_LINENO[$i-1]}p" $0 
    done

    gxmessage -file $file_error $GXMESSAGET -title "$0"
    exiting
}
#error_handler2(){
#trace 'problem'
#}
#error_handler3(){
#flite 'error handler'
#    local msg='found error'
#    trace "$msg"
#    Backtrace1
#    exit 1
#}
#


#error_handler(){
#die
#}
#
#
trace(){


    echo "_: $1 : $2 :$3" >&2
}
tracen(){

    echo  -n "${1}${2}" >&2
}
run_silently(){
    local cmd1="$1"
    eval "$cmd1" &> /dev/null &
}


caller1(){
local num="$1"
local str="${FUNCNAME[$num]}"
notify-send "caller" "$str"

}
xterm1(){
    trace "DEBUG : $DEBUG"
    trace "xterm1() got: 1:$1 2:$2 3:$3 4:$4"
    local prog="/usr/bin/xterm"

    local cmd="$1"
    #`echo $1`
    local msg="$2"
    #`echo $2`

    local arg3="$3"
    local arg4="$4"
    local func='gxmessage'
    local run1="$func hi"
    trace "cmd,msg: $cmd $msg"

    $( $prog -e $cmd "$msg" "$arg3" "$arg4"  ) &
    trace 'xterm exiting ?'
}

        export -f xterm1
export -f caller1 
export -f trace
export -f tracen 
export -f tracex
export -f exiting
export -f to_continue 
export -f debug
export -f got

export -f command_not_found_handler

export -f run_silently 

export -f breakpoint 
export -f die 

export -f assert_equal_str
export -f assert_equal_cmd
export -f assert_equal_file

#trap 'error ${LINENO} ${$?}' ERR
#trap SIGINT SIGTERM
# ! ! ! TRAP ERR ! ! !

#trap "eval exiting ${LINENO} ${$?}" SIGINT SIGTERM
#http://en.wikipedia.org/wiki/Unix_signal
trap exiting SIGINT SIGTERM
trap die ERR 
