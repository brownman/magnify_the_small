# Log Call Stack
#http://www.fvue.nl/wiki/Bash:_Error_handling
#http://www.linuxcommand.org/lc3_lts0080.php
#http://wiki.bash-hackers.org/commands/builtin/caller
#http://www.skybert.net/unix/bash/serious-programming-in-bash/
# about file:
# test the first test listen on blank.yaml:testing
#http://www.thegeekstuff.com/2010/10/expect-examples/#more-6218
    #args=$($tasks_sh fetch "$args0")
    #http://tldp.org/LDP/abs/html/comparison-ops.html
    #http://stackoverflow.com/questions/3265803/bash-string-equality
#cry
command_not_found_handler(){
    notify-send "You tried to run $1 with arg $2"
}

got(){
    local str="$@"
    notify-send  "got:" "$str" 
}
debug(){
    if [ "$VERBOSE" = true ];then
    #notify-send1
    trace "$@"
else
    tracen '$'
    fi

    #eval "$cmd1" &> /dev/null &

}


exiting()
{
    trace "exiting() got: 0:$0 1: $1 , 2: $2"
    notify-send1 "Exiting" "$file_locker" 
    #breakpoint false
    #"caller: ${FUNCNAME[2]}"

    #notify-send 'Exiting'
    #if [ "$VERBOSE" = true ];then
    #Backtrace1
    #trace 'backtrace'
    #fi

    flite 'exiting'
    #trace 'exiting'
    #die

    exit 1 
}


to_continue(){

    $( messageYN1 "test failed ?" "y/n" )
    #tracex 'is 1?' "$result"
    result=$?
    if [[ $result -eq 0 ]];then

        exiting
    else
        notify-send 'continue'
    fi



}



die(){


    echo -n '' > $file_error

    flite 'die'
    #gxmessage -file $file_error $GXMESSAGET
    breakpoint
    #zenity1 $file_error '' ''
    sleep1 10
    #remove_locker $file_locker
    exit 1
}
#show_caller(){
#
#    #gxmessage $GXMESSAGET "caller: ${FUNCNAME[2]} ${FUNCNAME[3]}  ${FUNCNAME[4]}"
#
#  }

breakpoint(){
    #show_caller
    echo -n '' > $file_error
   #flite 'step 1'

    # skipping i=0 as this is print_call_trace itself
    for ((i = 1; i < ${#FUNCNAME[@]}; i++)); do
        echo  "${BASH_SOURCE[$i]}:${BASH_LINENO[$i-1]}:${FUNCNAME[$i]} " >> $file_error
        sed -n "${BASH_LINENO[$i-1]}p" $0 
    done

    gxmessage -file $file_error $GXMESSAGET -title "$0"
    exiting
}
#error_handler2(){
#trace 'problem'
#}
#error_handler3(){
#flite 'error handler'
#    local msg='found error'
#    trace "$msg"
#    Backtrace1
#    exit 1
#}
#


#error_handler(){
#die
#}
#
#
trace(){


    echo "_: $1 : $2 :$3" >&2
}
tracen(){

    echo  -n "${1}${2}" >&2
}
run_silently(){
    local cmd1="$1"
    eval "$cmd1" &> /dev/null &
}


xterm1(){
    trace "DEBUG : $DEBUG"
    trace "xterm1() got: 1:$1 2:$2 3:$3 4:$4"
    local prog="/usr/bin/xterm"

    local cmd="$1"
    local msg="$2"

    local arg3="$3"
    local arg4="$4"
    local func='gxmessage'
    local run1="$func hi"
    trace "cmd,msg: $cmd $msg"

    $( $prog -e $cmd "$msg" "$arg3" "$arg4"  ) &
    trace 'xterm exiting ?'
}

        export -f xterm1
        
export -f trace
export -f tracen 

export -f exiting
export -f to_continue 
export -f debug
export -f got

export -f command_not_found_handler

export -f run_silently 

export -f breakpoint 
export -f die 



#trap 'error ${LINENO} ${$?}' ERR
#trap SIGINT SIGTERM
# ! ! ! TRAP ERR ! ! !

#trap "eval exiting ${LINENO} ${$?}" SIGINT SIGTERM
#http://en.wikipedia.org/wiki/Unix_signal
trap exiting SIGINT SIGTERM
trap die ERR 
