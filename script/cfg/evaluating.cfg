#http://mywiki.wooledge.org/BashFAQ/048
#http://wiki.bash-hackers.org/commands/builtin/eval

is_command(){
    local str="$1"
    case "$str" in
        !*) return $SUCCESS;;  # Begins with a letter?
            *) return $FAILURE;;
        esac
}

try(){
    local res=$(    remove_char "$1" "!")
        local command="$res"
        if [ "$COMMANDER" = true ];then

#local res=$(commander "$command")
            commander "$command"
        else
            eval "$command"
        fi

#local num=$?
}


reasoning(){
#local str="$1"
    random1 55
        local res=$?
#notify-send "god's Dice:" "$res" 
        #flite "god's dice" "$res"
        #sleep1 5
#--icon=""
        if [[ $res -eq 1 ]];then
            gxmessage "$reason" $GXMESSAGET

            quote
        elif [[ $res -eq 2 ]];then
                $tasks_sh menu
        else

            trace 'push koans'
        fi

#gxmessage "$str" $GXMESSAGET

}




helper0(){
    local str="$1"
        local file="$2"
        is_command "$str"
        res=$?


        if [[ $res -eq 1 ]];then

            update_file $file_log "$str"
            try "$str"
        else

        case "$str" in
            '')
            trace 'generate random phrase'
                        ;;
            'delete!')
                echo -n '' > $file
                ;;
     
            'exit!')
                flite 'breaking'
                exiting
                ;;
            'save!')
                update_file "$file_glossary" "$str"
                flite 'saving'
                ;;

        'practice!') 
        #notify-send "regexp ?" "$str"
        #COMMANDER=true
#\<c...h\>
               cmd1="$tasks_sh practice_regexp 
               #'\<$str\>'"
               commander "$cmd1"
                ;;
            *) 
                local res=$(spell2 "$str")
                if [ "$res" = 'error' ];then
                    trace 'error spelling'

                else
                    update_file $file "$res"
                    local ans=$(first_char "$res" " ")
                    if [ "$ans" = 'true' ];then
                        notify-send 'silent !'
                    else

                        (  echo01 "$res" &)
                        #notify-send 'talk !'
                    fi

                 fi
            ;;
            esac
                fi
}



eval1(){
    for i in 1 2 3
        do
            eval myvar="$i"
                echo "$myvar"
                done
## this gives 
#1
#2
#3
## why? because there is no metavalue or special meaning to 1 or 2 or 3
}

eval2(){
    for i in ls df
        do
            eval myvar="$i"
                echo "$myvar"
                done
# here you get output from the ls command and the df command
}


commander(){

    trace 'commander'
#flite 'commander'
        local cmd="$1"
        local input="$cmd"

        if [ "$COMMANDER" = 'true' ];then
            input=$(gxmessage -entrytext "$cmd" 'show command:' -title "commander:" $GXMESSAGET)
                fi

#helper "$input"
                local output1=`eval "$input"`
                local output2=$?

                if [ "$COMMANDER" = 'true' ];then
                    local silence=$(gxmessage "$output1" $GXMESSAGET -title 'OUTPUT:')
                        fi

                        echo "$output1"
}


export -f commander 
export -f helper0 


export -f reasoning 
export -f is_command 
export -f try 
