#http://mywiki.wooledge.org/BashFAQ/048
#http://wiki.bash-hackers.org/commands/builtin/eval

is_command(){
    local str="$1"
    case "$str" in
        !*) return $SUCCESS;;  # Begins with a letter?
            *) return $FAILURE;;
        esac
}

try(){
    local res=$(    remove_char "$1" "!")
        local command="$res"
        if [ "$COMMANDER" = true ];then

#local res=$(commander "$command")
            commander "$command"
        else
            eval "$command"
        fi

#local num=$?
}


reasoning(){
#local str="$1"
    random1 55
        local res=$?
#notify-send "god's Dice:" "$res" 
        #flite "god's dice" "$res"
        #sleep1 5
#--icon=""
        if [[ $res -eq 1 ]];then
            gxmessage "$reason" $GXMESSAGET

            quote
        elif [[ $res -eq 2 ]];then
                $tasks_sh menu
        else

            trace 'push koans'
        fi

#gxmessage "$str" $GXMESSAGET

}




helper0(){
    local str="$1"
        local file="$2"
        is_command "$str"
        res=$?


        if [[ $res -eq 1 ]];then

            update_file $file_log "$str"
            try "$str"
        else

        case "$str" in
            '')
            
           notify-send 'empty line' 
           
                        ;;
            'delete!')
                echo -n '' > $file
                ;;
     
            'exit!')
                flite 'breaking'
                exiting
                ;;
            'save!')
                update_file "$file_glossary" "$str"
                flite 'saving'
                ;;

        'practice!') 
        #notify-send "regexp ?" "$str"
        #COMMANDER=true
#\<c...h\>
               cmd1="$tasks_sh practice_regexp 
               #'\<$str\>'"
               commander "$cmd1"
                ;;
            *) 
                local res=$(spell2 "$str")
                if [ "$res" = 'error' ];then
                    trace 'error spelling'
fi
                    update_file $file "$str"
                    local ans=$(first_char "$str" " ")
                    if [ "$ans" = 'true' ];then
                        notify-send 'silent !'
                    else
mantion 'speak'
                        (  echo01 "$str" &)
                        #notify-send 'talk !'
                    fi

            ;;
            esac
                fi
}



eval1(){
    for i in 1 2 3
        do
            eval myvar="$i"
                echo "$myvar"
                done
## this gives 
#1
#2
#3
## why? because there is no metavalue or special meaning to 1 or 2 or 3
}

eval2(){
    for i in ls df
        do
            eval myvar="$i"
                echo "$myvar"
                done
# here you get output from the ls command and the df command
}


commander(){
local str1="${FUNCNAME[1]}"
#notify-send "commander:" "$str1"
    trace 'commander'
        local str="$1"

        #local cmd=$(echo "$str")
        local cmd="$str"

        if [ "$COMMANDER" = 'true' ];then
          local  input=$(gxmessage -entrytext "$cmd"  -title "BEFORE:"  "$str1" $GXMESSAGET)
                fi

                local output1=$(eval "$input")
                #local output2=$?

                if [ "$COMMANDER" = 'true' ];then
                    local output2=$(gxmessage -entrytext "$output1" -title "AFTER:" $GXMESSAGET "$str1")
                        fi

                        echo "$output2"
    #export COMMANDER=false
}


export -f commander 
export -f helper0 


export -f reasoning 
export -f is_command 
export -f try 
