#http://www.thegeekstuff.com/2009/03/15-practical-unix-grep-command-examples/
#http://dsl.org/cookbook/cookbook_5.html#SEC63 #pid
#http://www.thegeekstuff.com/2010/07/bash-string-manipulation/ 
#fs:
#find . -type f -print0 | xargs -0 du -h | sort -hr | head -20


choose_line1(){

#notify-send "$*"  "$0" 
local subject="$1"
local title="$2"
local text="$3"
local file=$(get_filename1 txt $subject )
#notify-send $file
local line=$(zenity1 $file "$title" "$text")
#local line=$(pick_line $file)
echo "$line"
}



get_filename1(){

#notify-send "$*"  "$0" 
local type="$1"
local subject="$2"
local file=''
local file=$DATA_DIR/${type}/${subject}.${type}
echo "$file"
}


remove_locker(){
local file="$1"
rmm "$file"
}
xterm(){
tracex 'xterm command not allowed'
}


echo0(){
 if [ $DEBUG = false ];then
     $PLUGINS_DIR/translation.sh sentence "$1" true  
 else
    trace 'echo0: silent'
 fi
}
unlocker1(){

local file_locker="$1"
    if [ -e $file_locker ];then

         trace 'locker exist'
         #notify-send "locker exist" "$file_locker"
         
        #notify-send 'locker exist'
         echo '0'
    else
    
        #notify-send 'fresh run'
        trace 'fresh run'
        echo '1'
    fi
}

unlocker(){

#local name1=$(ls -1 "$0")
#notify-send "unlocker: $1" "process: $$"
#local name="$1"
#local file_locker=$file_locker
#local delay=$delay
local gentle=${1:-$GENTLE}
local times=5
counter=0

if [ "$gentle" = true ];then
    while [[ $counter -lt $times ]];do
        trace "count: $counter"
        ans=$(unlocker1 $file_locker)
        if [ "$ans" = '0' ];then
            trace 'locker already exist'
            trace "translation delay: $delay"
            sleep1 "$delay"
        else 

            break
        fi
            let counter+=1
    done
replace_locker

else
    is_valid $file_locker 
    local res=$?
    if [ $res -eq 1 ];then
       trace "remove locker" "$file_locker"
        kill -9 $(cat $file_locker) &
    fi
    $(messageYN1 "$file_locker " 'unlock ?' '-iconic' $delay )
    res=$?
    if [ $res -eq 0 ];then
replace_locker
    fi
fi
}
replace_locker(){
remove_locker $file_locker &
        trace 'create locker'
        touch $file_locker
        echo $$ >> $file_locker
        trace 'running'
        run #who run the remove_locker when process itself exit
        trace 'remove locker'
remove_locker $file_locker &

}


echo01(){
local str="$1"
local res=$(last_char "$str" ' ')

 if [ $DEBUG = false ];then
    if [ "$res" = false ];then
         $PLUGINS_DIR/translation.sh sentence "$str" false false 
    else
         $PLUGINS_DIR/translation.sh sentence "$str" false true
    fi
 else
    trace 'echo0: silent'
 fi




}



suspension(){
    dbus-send --system --print-reply     --dest="org.freedesktop.UPower"     /org/freedesktop/UPower     org.freedesktop.UPower.Suspend
}




update_file(){
    trace "update_file got: file: $1 | msg: $2 | $3"
    local file="$1"
    local msg="$2"

    cat $file > /tmp/1.txt 
    echo "$msg" > $file
    cat /tmp/1.txt >> $file
}

xterm1(){
    trace "DEBUG : $DEBUG"
    trace "xterm1() got: 1:$1 2:$2 3:$3 4:$4"
    local prog="/usr/bin/xterm"

    local cmd="$1"
    #`echo $1`
    local msg="$2"
    #`echo $2`

    local arg3="$3"
    local arg4="$4"
    local func='gxmessage'
    local run1="$func hi"
    trace "cmd,msg: $cmd $msg"
#    if [ "$DEBUG" = true ];then
#    sleep1 3
#        #$cmd "$msg" "$arg3" "$arg4"
#
#( $cmd "$msg" "$arg3" "$arg4" &) 
#else
#
#trace 'run there'
#sleep1 3
##( exec $prog -e $cmd "$msg" "$arg3" "$arg4" &) 
#
#
##( $cmd "$msg" "$arg3" "$arg4" &) 
#
#sleep1 10
#        trace 'xterm run in other window'
#
#    fi
#
` $prog -e $cmd "$msg" "$arg3" "$arg4"  `
trace 'xterm exiting'
}

eacher(){
    trace "eacher() got: 1: $1     2: $2"

    local command="$1"
    local question="$2"
    local waiting="$3"

    local title="$4"
    local result=0
        #answer=
        $(messageYN1 "$question" "$title")
        answer=$?
        #yellow "$answer"
        if [[ $answer -eq 1 ]];then
            #echo 'exec command'
            eval "$command" 
            if [ "$waiting" != '' ];then
                sleep1 "$waiting"
            fi
            result=1
        fi
    return $result
}




sleep1()
{
    local sec="$1"

    trace "sleep ${sec}s"

#    for (( c=1; c<=$sec; c++ ))
#    do
#        #tracen  "$c "
#        #echo ''
#        sleep 1s
#    done

        sleep ${sec}s


}

red() {
    echo "${LRED}$1"
    tput sgr0
}


tracen(){
    #if [ "$VERBOSE" = true ];then

        #echo -n "$1 :" >&2
        echo  "$1 :" >&2
    #fi
}

remove_trailing(){
    trace 'remove_trailing'
    echo "$1" | sed -e 's/^ *//g' -e 's/ *$//g'


    #http://stackoverflow.com/questions/369758/how-to-trim-whitespace-from-bash-variable
}

spell2(){
    local str="$1"
    local res=`echo "$str" |  aspell -a | grep  ','`
    if [  "$res" = '' ];then
        echo "$str"
    else
        trace "$res"
        notify-send "$res"
        echo "error"
    fi
}

help1(){
    trace "options: "
trace "$1"
}
generate_line(){
local  file=$(generate_file "$1")
local str=$( pick_line $file)
echo "$str"
}

generate_file(){
local file=$DATA_DIR/txt/${1}.txt 
touch $file
echo "$file"
}


flite(){
    trace "flite() got: 1:$1 2:$2 3:$3"
    #local must="$2"
    sleep1 1

        local desc="$1"

        local desc2="$2"
#[  "$must" = 'true' ] ||
    if  [ "$SILENCE" = false ];then
        local cmd=/usr/bin/flite

        notify-send "say:" "$desc : $desc2"
        ( echo "$desc" | $cmd &)
        #gxmessage "flite: $desc" $GXMESSAGET
    else
        trace 'flite is muted'
        notify-send 'silence' "$1   :   $2"
    fi
}

line_strip(){
    local line="$1"
    local file=$2
    
    local num=$(echo "$line" | awk -F '|' '{print $1}')
    local res=$(echo "$line" | awk -F '|' '{print $2}')



for (( c=1; c<=$num; c++ ))
    do
echo "$res" >> $file
    done

    #echo "$num"

}

file_to_lines(){
    trace "read_lines() got:  1:$1 2:$2"
    local file="$1"

    while read -r line
    do
        [[ $line = \#* ]] && continue
        #echo "$line"
        #lines=("${lines[@]}" "$line")
        if [ "$line" != ''  ];then
            #trace "line: $line"
            lines+=("$line")
        fi
    done < "$file"

#local msg=$(echo "${lines[@]}")
#notify-send "$msg"
#echo "$msg"
#echo 'good'
    #echo "lines: ${lines}"
}

rmm(){
if [ -s "$1" ];then
    rm  "$1"
fi


}

execute_lines(){
#input: lines
#echo "${lines[@]}"
local tmp=''
    max=${#lines[@]}
    count=1

             #notify-send " recent translation: $count"
    for line in "${lines[@]}"
    do
             #echo   'execute_line "$line" "$str2"'



           #tmp=$( "$cmd" "$line")
           eval "$cmd"
            #notify-send "$tmp"
            #echo "$tmp"

                #sleep1 1
             #echo4 "$line" 
             #echo "$line"
#    if [[ $count -eq 4 ]];then
#    flite 'breaking'
#break
#fi

 let "count=count+1"
    done


}

lower() { echo ${@,,}; }

higher() { echo ${@^^}; }

#
export -f tracen 
export -f trace 

export -f lower 
export -f update_file 

export -f echo0 
export -f echo01 

export -f sleep1
export -f remove_trailing 
export -f remove_locker

export -f spell2 
export -f flite 
export -f rmm 
export -f file_to_lines 
export -f eacher
export -f execute_lines
export -f generate_line 
export -f generate_file 
export -f xterm1

export -f flite 
export -f higher
export -f xterm1
export -f unlocker1 
export -f unlocker 
export -f choose_line1
export -f get_filename1

export -f help1
export -f replace_locker 

