#http://www.thegeekstuff.com/2009/03/15-practical-unix-grep-command-examples/
#http://dsl.org/cookbook/cookbook_5.html#SEC63 #pid
#http://www.thegeekstuff.com/2010/07/bash-string-manipulation/ 
#fs:
#find . -type f -print0 | xargs -0 du -h | sort -hr | head -20




choose_line1(){

    #notify-send "$*"  "$0" 
    local subject="$1"
    local title="$2"
    local text="$3"
    local file=$(get_filename1 txt $subject )
    #notify-send $file
    local line=$(zenity1 $file "$title" "$text")
    #local line=$(pick_line $file)
    echo "$line"
}



get_filename1(){

    #notify-send "$*"  "$0" 
    local type="$1"
    local subject="$2"
    local file=''
    local file=$DATA_DIR/${type}/${subject}.${type}
    echo "$file"
}



xterm(){
    tracex 'xterm command not allowed'
}


echo0(){
    if [ $DEBUG = false ];then
        $PLUGINS_DIR/translation.sh sentence "$1" true  
    else
        trace 'echo0: silent'
    fi
}

echo01(){
    local str="$1"
    if [ "$str" ];then


        local res=$(last_char "$str" ' ')

        if [ "$DEBUG" = false ];then
            if [ "$res" = false ];then
                $PLUGINS_DIR/translation.sh sentence "$str" false false 
            else
                $PLUGINS_DIR/translation.sh sentence "$str" false true
            fi
        else
            trace 'echo0: silent'
            mantion 'echo01-debug is true -> silent'
        fi
        $PLUGINS_DIR/translation.sh sentence "$str"


    fi


}



suspension(){
    dbus-send --system --print-reply     --dest="org.freedesktop.UPower"     /org/freedesktop/UPower     org.freedesktop.UPower.Suspend
}




update_file(){
    trace "update_file got: file: $1 | msg: $2 | $3"
    local file="$1"
    local msg="$2"

    cat $file > /tmp/1.txt 
    echo "$msg" > $file
    cat /tmp/1.txt >> $file
}

xterm1(){
    trace "DEBUG : $DEBUG"
    trace "xterm1() got: 1:$1 2:$2 3:$3 4:$4"
    local prog="/usr/bin/xterm"

    local cmd="$1"
    #`echo $1`
    local msg="$2"
    #`echo $2`

    local arg3="$3"
    local arg4="$4"
    local func='gxmessage'
    local run1="$func hi"
    trace "cmd,msg: $cmd $msg"

    $( $prog -e $cmd "$msg" "$arg3" "$arg4"  ) &
    trace 'xterm exiting ?'
}

sleep1()
{
    local sec="$1"
    if [ "$sec" = '' ];then
        notify-send "sleep1" "error: no param: Xs"
        breakpoint
        sec=30
    fi


    trace "sleep ${sec}s"

    for (( c=1; c<=$sec; c++ ))
    do
        #tracen  "$c "
        #echo ''
        sleep 1s
    done

    #sleep ${sec}s


}

red() {
    echo "${LRED}$1"
    tput sgr0
}




remove_trailing(){
    trace 'remove_trailing'
    echo "$1" | sed -e 's/^ *//g' -e 's/ *$//g'


    #http://stackoverflow.com/questions/369758/how-to-trim-whitespace-from-bash-variable
}

speller(){
    local str="$1"
    local res=`echo "$str" |  aspell -a | grep  ','`
    if [  "$res" = '' ];then
        echo "$str"
    else
        trace "$res"
        notify-send1 "$res"

        #echo "error"
        breakpoint
    fi
}

help1(){
    trace "options: "
    trace "$1"
}
generate_line(){

    local type=${2:-'txt'}
    local name=$1
    local cmd="generate_file $name $type"

    local  file=$(generate_file "$name" "$type")


    local str=$( pick_line $file )

    #assert_equal_str "pick line: $str"
    echo "$str"
}

generate_file(){
    #gxmessage $GXMESSAGET  'generate file'
    #sleep1 10
    local name=$1
    local type=$2
    local file=$DATA_DIR/${type}/$name.${type}
    #assert_equal_str $file

    touch $file
    echo "$file"
}


flite(){
    trace "flite() got: 1:$1 2:$2 3:$3"
    #local must="$2"
    #sleep1 1

    local desc="$1"

    local desc2="$2"
    #[  "$must" = 'true' ] ||
        if  [ "$SILENCE" = 'false' ];then
            local cmd=/usr/bin/flite

            notify-send "say:" "$desc : $desc2"
            ( echo "$desc" | $cmd &)
            #gxmessage "flite: $desc" $GXMESSAGET
        else
            trace 'flite is muted'
            #notify-send 'silence' "$1   :   $2"
        fi
    }

    line_strip(){
        local line="$1"
        local file=$2

        local num=$(echo "$line" | awk -F '|' '{print $1}')
        local res=$(echo "$line" | awk -F '|' '{print $2}')



        for (( c=1; c<=$num; c++ ))
        do
            echo "$res" >> $file
        done

        #echo "$num"

    }

    file_to_lines(){
        trace "read_lines() got:  1:$1 2:$2"
        local file="$1"

        while read -r line
        do
            [[ $line = \#* ]] && continue
            #echo "$line"
            #lines=("${lines[@]}" "$line")
            if [ "$line" != ''  ];then
                #trace "line: $line"
                lines+=("$line")
            fi
        done < "$file"

        #local msg=$(echo "${lines[@]}")
        #notify-send "$msg"
        #echo "$msg"
        #echo 'good'
        #echo "lines: ${lines}"
    }



    execute_lines(){
        #input: lines
        #echo "${lines[@]}"
        local tmp=''
        max=${#lines[@]}
        count=1

        #notify-send " recent translation: $count"
        for line in "${lines[@]}"
        do
            eval "$cmd"
            let "count=count+1"
        done


    }

    lower() { echo ${@,,}; }

    higher() { echo ${@^^}; }

    #

    eacher(){
        trace "eacher() got: 1: $1     2: $2"

        local command="$1"
        local question="$2"
        local waiting="$3"

        local title="$4"
        local result=0
        $(messageYN1 "$question" "$title")
        answer=$?
        #yellow "$answer"
        if [[ $answer -eq 1 ]];then
            #echo 'exec command'
            eval "$command" 
            if [ "$waiting" != '' ];then
                sleep1 "$waiting"
            fi
            result=1
        fi
        return $result
    }

    sleep3(){
    
ffmpeg -i %f -vn -ar 44100 -ac 2 -ab 128 -f mp3 %f.mp3 | yad --progress --percentage=40 --progress-text="Please wait ... file being processed" --title="Audio Extraction" --auto-close --auto-kill

    }
    get_time(){
        local limit="$1"
    local date2=$(date --date="$limit seconds" +%H:%M)
 echo "$date2"
    }


          export -f get_time 
          export -f lower 
        export -f update_file 

        export -f echo0 
        export -f echo01 


        export -f remove_trailing 


        export -f speller 

        export -f file_to_lines 

        export -f execute_lines
        export -f generate_line 
        export -f generate_file 

        export -f flite 
        export -f higher
        export -f xterm1

        export -f choose_line1
        export -f get_filename1

        export -f help1


        export -f eacher



        export -f sleep1


        
