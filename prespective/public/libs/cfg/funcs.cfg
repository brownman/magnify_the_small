#http://www.thegeekstuff.com/2009/03/15-practical-unix-grep-command-examples/
#http://dsl.org/cookbook/cookbook_5.html#SEC63 #pid
#http://www.thegeekstuff.com/2010/07/bash-string-manipulation/ 
parse_subject(){
trace  "parse subject $1|  $2"
local subject="$1"
local file_to=$CFG_DIR/tmp/${subject}.cfg
#touch $file_to
local cmd=$( echo "cat $file_data | shyaml get-values $subject" )
local results=$(commander "$cmd")
#echo "$results"
#local results="$cmd"
#$(eval $cmd)
echo "$results" > $file_to
#local ans=$(cat $file_to )
#echo "$results"
}

unpack_subject(){
local subject="$1"
local file=$CFG_DIR/tmp/${subject}.cfg
    #local res=$(parse_subject1 "$subject")
    #echo "$res" > $fil[M N2]e_from 


    #parse_subject $name $file
        local lines=()
        
        file_to_lines $file
    echo -n '' > $file #replace file's content
    
        local cmd='line_strip "$line" $file'

    #local res=$( execute_lines )
    execute_lines 

local res=$(random_from_subject "$subject")
notify-send "$res"
echo "$res"

}
random_from_subject(){
local subject="$1"
local file=$(get_filename $subject )
local line=$(pick_line $file)
echo "$line"
}

get_filename(){
local subject="$1"
local file=$CFG_DIR/tmp/${subject}.cfg
echo "$file"
}

die(){
#http://wiki.bash-hackers.org/commands/builtin/caller

  local frame=0
 
local file=/tmp/error.txt

  while caller $frame; do
    ((frame++));
  done
#gxmessage "$*" 
  echo "$*" > $file
  cat $file
  #gxmessage -file "$file" $GXMESSAGET
  #zenity1 "$file" 

flite 'die'
remove_locker $file_locker
sleep1 10
  exit 1

}
remove_locker(){
rmm $1
}
xterm(){
tracex 'xterm command not allowed'
}
zenity1(){
 #find . -name '*.txt' 
 local file="$1"
 cat $file | zenity --list --title "Search Results" --text "Finding all header files.." --column "Files"
}

echo0(){
 if [ $DEBUG = false ];then
     $PLUGINS_DIR/translation.sh sentence "$1" true  
 else
    trace 'echo0: silent'
 fi
}
unlocker1(){

local file_locker="$1"
    if [ -e $file_locker ];then

         trace 'locker exist'
         #notify-send "locker exist" "$file_locker"
         
        #notify-send 'locker exist'
         echo '0'
    else
    
        #notify-send 'fresh run'
        trace 'fresh run'
        echo '1'
    fi
}

unlocker(){

#local name1=$(ls -1 "$0")
#notify-send "unlocker: $1" "process: $$"
#local name="$1"
local file_locker=$file_locker

local delay=$delay
#{1:-4}
local gentle=${2:-$GENTLE}
counter=0

if [ "$gentle" = true ];then
    while [[ $counter -lt 5 ]];do
        trace "count: $counter"
        ans=$(unlocker1 $file_locker)
        if [ "$ans" = '0' ];then
            trace 'locker already exist'
            trace "translation delay: $delay"
            sleep1 "$delay"
        else 
            break
        fi
            let counter+=1
    done

    run
else


    is_valid $file_locker
    local res=$?
    if [ $res -eq 1 ];then
        notify-send "remove locker" "$file_locker"
        kill -9 $(cat $file_locker) &
    fi

    $(messageYN1 "$file_locker " 'kill ?' '-iconic' $delay )
    res=$?


    if [ $res -eq 1 ];then

remove_locker $file_locker &

        #exiting 
        trace 'create locker'
        touch $file_locker
        echo $$ >> $file_locker
        trace 'running'
        run
        trace 'remove locker'


remove_locker $file_locker &
    fi
 
fi




}


echo01(){
local str="$1"
local res=$(last_char "$str" ' ')

 if [ $DEBUG = false ];then
    if [ "$res" = false ];then
         $PLUGINS_DIR/translation.sh sentence "$str" false false 
    else
         $PLUGINS_DIR/translation.sh sentence "$str" false true
    fi
 else
    trace 'echo0: silent'
 fi




}
debug(){
trace "$2"
}


suspension(){
    dbus-send --system --print-reply     --dest="org.freedesktop.UPower"     /org/freedesktop/UPower     org.freedesktop.UPower.Suspend
}

is_valid(){
    trace  "is_valid() got:"
    trace "1:$1 2:$2"

    if [ "$1" = '' ];then
        trace 'no arg given'
        #error_handler
        return
    fi

    local file=$1
    local result=0
    debug yellow 'check existance'
    if [ $file ];then
        debug green 'file exist'
        if  [ -s $file ];then
            debug green 'file has content'
            actualsize=$(du -b "$file" | cut -f 1)
            trace 'size: '
            debug trace $actualsize

            if [ $actualsize -eq 0 ];then
                debug red  'file is corrupted'
                #let "result = 1"
            else
                debug green 'file seems ok'
                let "result = 1"
            fi
        else
            debug red 'file is empty'
        fi
    else
        debug red 'file not exist'
    fi
    return $result
}


update_file(){
    trace "update_file got: file: $1 | msg: $2 | $3"
    local file="$1"
    local msg="$2"

    cat $file > /tmp/1.txt 
    echo "$msg" > $file
    cat /tmp/1.txt >> $file
}

xterm1(){
    trace "DEBUG : $DEBUG"
    trace "xterm1() got: 1:$1 2:$2 3:$3 4:$4"
    local prog="/usr/bin/xterm"

    local cmd="$1"
    #`echo $1`
    local msg="$2"
    #`echo $2`

    local arg3="$3"
    local arg4="$4"
    local func='gxmessage'
    local run1="$func hi"
    trace "cmd,msg: $cmd $msg"
#    if [ "$DEBUG" = true ];then
#    tracex 'debug: true'
#    sleep1 3
#        #$cmd "$msg" "$arg3" "$arg4"
#
#( $cmd "$msg" "$arg3" "$arg4" &) 
#else
#
#    tracex 'debug: false'
#trace 'run there'
#sleep1 3
##( exec $prog -e $cmd "$msg" "$arg3" "$arg4" &) 
#
#
##( $cmd "$msg" "$arg3" "$arg4" &) 
#
#sleep1 10
#        trace 'xterm run in other window'
#
#    fi
#
` $prog -e $cmd "$msg" "$arg3" "$arg4"  `
trace 'xterm exiting'
}

eacher(){
    trace "eacher() got: 1: $1     2: $2"

    local command="$1"
    local question="$2"
    local waiting="$3"

    local title="$4"
    local result=0
        #answer=
        $(messageYN1 "$question" "$title")
        answer=$?
        #yellow "$answer"
        if [[ $answer -eq 1 ]];then
            #echo 'exec command'
            eval "$command" 
            if [ "$waiting" != '' ];then
                sleep1 "$waiting"
            fi
            result=1
        fi
    return $result
}


messageYN1() {

    trace "messageYN got: 1: $1 2: $2 3:$3"

    local iconic="$3"

    local str="$1"
    local title=${2:-'y/n question'}   # Defaults to /tmp dir.
    local result=0
    local delay="$4"
  
  if [ "$delay" = '' ];then
           $( gxmessage -buttons 'back:0,Next!:1' -title "$title" "$str"  $GXMESSAGET "$iconic"  )
  else
           $( gxmessage -buttons 'back:0,Next!:1' -title "$title" "$str"  "$iconic" -timeout $delay )
  fi


        result=$?

    return $result
}



sleep1()
{
    local sec="$1"

    trace "sleep ${sec}s"

    for (( c=1; c<=$sec; c++ ))
    do
        #tracen  "$c "
        #echo ''
        sleep 1s
    done


}

red() {
    echo "${LRED}$1"
    tput sgr0
}

trace(){

    if [ "$VERBOSE" = false ];then
        echo "_: $1 : $2 :$3" >&2
    fi
}
helper0(){
local str="$1"
local file="$2"

 case "$1" in
'')

    local line1=$(cat $file | head -1)
   if [ "$line1" = '' ];then
            echo01 "$line1" &
   fi


;;
'delete!')

echo -n '' > $file
;;
'help!')
trace ''
;;
'exit!')

            flite 'breaking'
exiting
;;
'save!')
  update_file "$file_glossary" "$str"
    flite 'saving'

;;
'listen!')

               $tasks_sh learn_langs & 
;;
'read!')
local lang=$(higher "$LANG_DEFAULT")
        (exo-open "http://www.goethe-verlag.com/book2/EN/EN${lang}/EN${lang}002.HTM" &)
;;
'remind!')

$tasks_sh show_msg_entry tasks & 
;;
   *) 
           local res=$(spell2 "$str")
           if [ "$res" = 'error' ];then
               trace 'error spelling'
         
           else
              update_file $file "$res"
            (  echo01 "$res" &)
           fi
           ;;
esac
}


tracen(){
    #if [ "$VERBOSE" = true ];then

        #echo -n "$1 :" >&2
        echo  "$1 :" >&2
    #fi
}
exiting()
{
    trace "exiting() got: 0:$0 1: $1 , 2: $2"
  
    #notify-send 'Exiting'
    #if [ "$VERBOSE" = true ];then
        #Backtrace1
        #trace 'backtrace'
    #fi
    
    #flite exiting
#trace 'exiting'
die
}






tracex(){

    local btn_str="${3:-ok}"
    local title="$1"
    local msg="$2"

    gxmessage $GXMESSAGET "$msg" -title "$title" -buttons "$btn_str":0 $ICONIC

    #flite "$1"
}
remove_trailing(){
    trace 'remove_trailing'
    echo "$1" | sed -e 's/^ *//g' -e 's/ *$//g'


    #http://stackoverflow.com/questions/369758/how-to-trim-whitespace-from-bash-variable
}

spell2(){
    local str="$1"
    local res=`echo "$str" |  aspell -a | grep  ','`
    if [  "$res" = '' ];then
        echo "$str"
    else
        trace "$res"
        notify-send "$res"
        echo "error"
    fi
}

help1(){
    trace "options: "
trace "$1"
}
error_handler2(){
trace 'problem'
}
error_handler3(){
flite 'error handler'
    local msg='found error'
    trace "$msg"
    Backtrace1
    exit 1
}

error_handler(){
die
}
error_handler1(){
die
}
function Backtrace1 
{
#flite 'back - trace'
    local _start_from_=0

    local params=( "$@" )
    if (( "${#params[@]}" >= "1" ))
    then
        _start_from_="$1"
    fi

    local i=0
    local first=false
    while caller $i > /dev/null
    do
        if test -n "$_start_from_" && (( "$i" + 1   >= "$_start_from_" ))
        then
            if test "$first" == false
            then
                trace "BACKTRACE IS:"
                first=true
            fi
            caller $i
        fi
        let "i=i+1"
    done
    if [ $PAUSE = true ];then
 flite 'sleep 10 seconds'
    sleep1 10
    else

 trace "don't sleep 10 seconds"
    fi
   
    trace '_+_+_+_+_+'
}
string_ws(){
local str="$1"


local str_ws=$(echo "$str"|sed 's/ /_/g');
echo "$str_ws"

}
generate_line(){
local  file=$(generate_file "$1")
local str=$( pick_line $file)
echo "$str"
}

generate_file(){
local file=$CFG_DIR/txt/${1}.txt 
touch $file
echo "$file"
}

pick_line(){
    trace "pick_line() got: $1"

    local file=$1
    local files1=$(ls  $file 2> /dev/null )
    if [ ! "$files1" ];then
        #error_handler 
        trace 'no file'
        return
    fi

    local str=`cat $file | sort --random-sort | head -n 1`

    trace "choosen line: "
    trace "$str"

    echo "$str" 
}

random_quote_before(){
        $tasks_sh motivation short 

}

random_quote_after(){
        $tasks_sh motivation guidance 
}



commander(){
trace 'commander'
local cmd="$1"
local input="$cmd"

if [ "$COMMANDER" = 'true' ];then
input=$(gxmessage -entrytext "$cmd" 'show command:' -title "commander:" $GXMESSAGET)
fi

#helper "$input"
local output1=`eval "$input"`
local output2=$?

if [ "$COMMANDER" = 'true' ];then
local silence=$(gxmessage "$output1" $GXMESSAGET -title 'OUTPUT:')
fi

echo "$output1"
}
#
#fetching2(){
#
#local cmd=$( echo "cat $file_data | shyaml $1" )
##commander "$cmd"
# local msg1=`eval "$cmd"`
# #` cat $file_data | shyaml "$1" `
#    #trace "msg1: $msg1" 'message'
#
#    echo "$msg1"
#
#}
#
#fetching(){
#
#local ans=$( fetching1 "$1" )
#
#trace "ans: $ans"
#local ans2=$( fetching2 "$ans" )
#
#    #tracex "$ans2" 'fetching 2' 
#trace "ans1: $ans1"
#
##local     res=$( echo "$ans2" | awk -F "\n" '{print $1}' )
#echo "$ans2" > $file_recent
#local line=$(cat $file_recent | head -1)
#echo "$line"
##trace "ans2: $ans2"
#}

function error() {
JOB="$0"              # job name
LASTLINE="$1"         # line of error occurrence
LASTERR="$2"          # error code
echo "ERROR in ${JOB} : line ${LASTLINE} with exit code ${LASTERR}"
#Backtrace1
exit 1
}


flite(){
    trace "flite() got: 1:$1 2:$2"
    local must="$2"
    sleep1 1
#[  "$must" = 'true' ] ||
    if  [ "$SILENCE" = false ];then
        local cmd=/usr/bin/flite
        local desc="$1"
        notify-send "say:" "$desc"
        ( echo "$desc" | $cmd &)
        #gxmessage "flite: $desc" $GXMESSAGET
    else
        trace 'flite is muted'
    fi
}

line_strip(){
    local line="$1"
    local file=$2
    
    local num=$(echo "$line" | awk -F '|' '{print $1}')
    local res=$(echo "$line" | awk -F '|' '{print $2}')



for (( c=1; c<=$num; c++ ))
    do
echo "$res" >> $file
    done

    #echo "$num"

}

file_to_lines(){
    trace "read_lines() got:  1:$1 2:$2"
    local file="$1"

    while read -r line
    do
        [[ $line = \#* ]] && continue
        #echo "$line"
        #lines=("${lines[@]}" "$line")
        if [ "$line" != ''  ];then
            #echo "line: $line"
            lines+=("$line")
        fi
    done < "$file"

#local msg=$(echo "${lines[@]}")
#notify-send "$msg"
#echo "$msg"
#echo 'good'
    #echo "lines: ${lines}"
}

rmm(){
if [ -s "$1" ];then
    rm  "$1"
fi


}

execute_lines(){
#input: lines
#echo "${lines[@]}"
local tmp=''
    max=${#lines[@]}
    count=1

             #notify-send " recent translation: $count"
    for line in "${lines[@]}"
    do
             #echo   'execute_line "$line" "$str2"'



           #tmp=$( "$cmd" "$line")
           eval "$cmd"
            #tmp=$(commander "$cmd $line")
            #notify-send "$tmp"
            #echo "$tmp"

                #sleep1 1
             #echo4 "$line" 
             #echo "$line"
#    if [[ $count -eq 4 ]];then
#    flite 'breaking'
#break
#fi

 let "count=count+1"
    done


}

lower() { echo ${@,,}; }

higher() { echo ${@^^}; }

random1()
{
    local num="$1"
    if [ $num -eq 0 ];then
        #error_handler
        trace 'no num'
        return
    fi

    let "r = $RANDOM % $num"
    #green "r = $r"
    #counter=$r
    #let "reminder = $counter % 4"
    #echo1 "the reminder is: $reminder"
    return $r
}

#trap 'error ${LINENO} ${$?}' ERR
trap die ERR                                                           # ! ! ! TRAP ERR ! ! !

trap "eval exiting ${LINENO} ${$?}" SIGINT SIGTERM

#
export -f unpack_subject 
export -f trace
export -f tracex
export -f update_file 
export -f debug
export -f messageYN1
export -f echo0 
export -f echo01 
export -f exiting
export -f parse_subject 
#export -f fetching1 
#export -f fetching2
#export -f fetching
export -f sleep1

export -f remove_trailing 
export -f remove_locker
export -f tracen 
export -f trace 
export -f Backtrace1
export -f is_valid 
export -f spell2 
export -f error_handler
export -f error_handler1
export -f rmm 
export -f file_to_lines 
export -f execute_lines
export -f flite 
export -f string_ws 
export -f generate_line 

#export -f generate_from_cfg 
#export -f generate_cfg 
export -f generate_file 
export -f random1 
export -f commander 
export -f xterm1
export -f lower 
export -f flite 
export -f higher
export -f pick_line
export -f xterm1

export -f eacher
export -f helper0 

export -f unlocker1 
export -f die 

export -f unlocker 

export -f zenity1 

export -f random_from_subject
export -f get_filename 

tracen "DEBUG: $DEBUG"
tracen "VERBOSE: $VERBOSE"
